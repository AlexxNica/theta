class HTMLPlatform :: Platform {
	var _width = 0
	var _height = 0
	var _density = 0.0
	var _pixelWidth = 0
	var _pixelHeight = 0
	var _context = GPU.HTMLContext.new
	var _delegate Platform.Delegate = null
	var _hasFocus = true

	def new {
		var isOSX = navigator.platform == "MacIntel" || navigator.platform == "MacPPC"
		var canvas = _context.gl.canvas
		var centroid = Vector.new
		var isHidden = false
		var isBlurred = false

		var handleFocusChange = => {
			_hasFocus = !isBlurred && !isHidden
			if _delegate != null {
				_delegate.handleFocusChange
			}
		}

		var resize = => {
			_width = window.innerWidth
			_height = window.innerHeight
			_density = window.devicePixelRatio
			_pixelWidth = Math.round(_width * _density) as int
			_pixelHeight = Math.round(_height * _density) as int
			_context.resize(_pixelWidth, _pixelHeight)
			if _delegate != null {
				_delegate.handleResize
			}
		}

		var tick fn() = => {
			if _delegate != null {
				_delegate.handleFrame
			}
			requestAnimationFrame(tick)
		}

		var flagsFromEvent = (e HTMLKeyboardEvent) Platform.KeyFlags => {
			return
				(e.altKey ? .ALT : 0) |
				((isOSX ? e.metaKey : e.ctrlKey) ? .META : 0) |
				(e.shiftKey ? .SHIFT : 0)
		}

		canvas.addEventListener("wheel", (e HTMLWheelEvent) => {
			var swap = !isOSX && e.shiftKey
			if e.ctrlKey || isOSX && e.metaKey {
				if _delegate != null {
					_delegate.handlePinch(e.pageX, e.pageY, e.deltaY)
				}
			} else {
				if _delegate != null {
					_delegate.handleScroll(
						swap ? e.deltaY : e.deltaX,
						swap ? e.deltaX : e.deltaY)
				}
			}
			e.preventDefault
		})

		canvas.addEventListener("touchstart", (e HTMLTouchEvent) => {
			e.preventDefault

			if _delegate != null {
				var touches = e.touches
				_computeCentroid(touches, centroid)
				_delegate.handleTouchStart(centroid.x, centroid.y, _computeDistance(touches, centroid))
			}
		})

		canvas.addEventListener("touchmove", (e HTMLTouchEvent) => {
			if _delegate != null {
				var touches = e.touches
				_computeCentroid(touches, centroid)
				_delegate.handleTouchMove(centroid.x, centroid.y, _computeDistance(touches, centroid))
			}
		})

		canvas.addEventListener("touchend", (e HTMLTouchEvent) => {
			if _delegate != null {
				var touches = e.touches
				_computeCentroid(touches, centroid)
				_delegate.handleTouchEnd(centroid.x, centroid.y, _computeDistance(touches, centroid))
			}
		})

		document.addEventListener("keydown", (e HTMLKeyboardEvent) => {
			var shortcut Platform.Shortcut
			var which = e.which
			var isLine = isOSX && e.metaKey
			var isWord = isOSX ? e.altKey : e.ctrlKey
			var hasShortcut = true

			const KEY_BACKSPACE = 8
			const KEY_END = 35
			const KEY_HOME = 36
			const KEY_LEFT = 37
			const KEY_UP = 38
			const KEY_RIGHT = 39
			const KEY_DOWN = 40
			const KEY_DELETE = 46

			if which == KEY_BACKSPACE { shortcut = isWord ? .DELETE_LEFT_WORD : .DELETE_LEFT_CHARACTER }
			else if which == KEY_LEFT { shortcut = isLine ? .MOVE_LEFT_LINE : isWord ? .MOVE_LEFT_WORD : .MOVE_LEFT_CHARACTER }
			else if which == KEY_RIGHT { shortcut = isLine ? .MOVE_RIGHT_LINE : isWord ? .MOVE_RIGHT_WORD : .MOVE_RIGHT_CHARACTER }
			else if which == KEY_UP { shortcut = .MOVE_UP }
			else if which == KEY_DOWN { shortcut = .MOVE_DOWN }
			else if which == KEY_DELETE { shortcut = isWord ? .DELETE_RIGHT_WORD : .DELETE_RIGHT_CHARACTER }
			else if which == KEY_HOME { shortcut = .MOVE_LEFT_LINE }
			else if which == KEY_END { shortcut = .MOVE_RIGHT_LINE }
			else if which == 'K' && isOSX && e.ctrlKey { shortcut = .DELETE_RIGHT_LINE }
			else { hasShortcut = false }

			if hasShortcut {
				e.preventDefault
				if _delegate != null {
					_delegate.handleShortcut(shortcut, flagsFromEvent(e))
				}
			}
		})

		document.addEventListener("keypress", (e HTMLKeyboardEvent) => {
			var code = e.which
			if _delegate != null && (
				code >= 'a' && code <= 'z' ||
				code >= 'A' && code <= 'Z' ||
				code >= '0' && code <= '9' || code == '.' ||
				code == '+' || code == '-' || code == '*' || code == '/' ||
				code == '<' || code == '>' || code == '≤' || code == '≥' || code == '=' ||
				code == ','
			) {
				_delegate.handleCodePoint(code, flagsFromEvent(e))
			}
		})

		document.addEventListener("visibilitychange", => {
			isHidden = document.hidden
			handleFocusChange()
		})

		window.addEventListener("blur", => {
			isBlurred = true
			handleFocusChange()
		})

		window.addEventListener("focus", => {
			isBlurred = false
			handleFocusChange()
		})

		_context.gl.getExtension("OES_standard_derivatives")
		window.addEventListener("resize", resize)
		document.body.appendChild(canvas)
		resize()
		tick()
	}

	def hasFocus bool {
		return _hasFocus
	}

	def width int {
		return _width
	}

	def height int {
		return _height
	}

	def density double {
		return _density
	}

	def pixelWidth int {
		return _pixelWidth
	}

	def pixelHeight int {
		return _pixelHeight
	}

	def seconds double {
		return performance.now / 1000
	}

	def context GPU.Context {
		return _context
	}

	def setDelegate(delegate Platform.Delegate) {
		_delegate = delegate
	}

	def _computeCentroid(touches List<HTMLTouch>, centroid Vector) {
		centroid.set(0, 0)
		for touch in touches {
			centroid.x += touch.pageX
			centroid.y += touch.pageY
		}
		centroid /= touches.count
	}

	def _computeDistance(touches List<HTMLTouch>, centroid Vector) double {
		var distance = 0.0
		for touch in touches {
			var dx = touch.pageX - centroid.x
			var dy = touch.pageY - centroid.y
			distance += Math.sqrt(dx * dx + dy * dy)
		}
		return distance / touches.count
	}
}
