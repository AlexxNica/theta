class GlyphInstance {
	var glyph Glyph = null
	var offset = Vector.new
	var scale = 0.0
}

class Canvas :: Layout.Renderer {
	var _platform Platform
	var _context GPU.Context
	var _pool GPU.BufferPool
	var _smooth GPU.Smooth
	var _demoMaterial GPU.Material
	var _glyphMaterial GPU.Material
	var _textMaterial GPU.Material
	var _font Font
	var _quad GPU.BufferArea
	var _color GPU.Texture
	var _target GPU.TextureSet
	var _instances List<GlyphInstance> = []
	var _usedInstances = 0
	var _isInvalid = true
	var _validFrames = 0

	# Viewport transform
	var _origin = Vector.new
	var _scale = 100.0

	# Temporary objects to avoid GC
	var _transformA = Transform.new
	var _transformB = Transform.new

	def new(platform Platform, fontData DataArray) {
		_platform = platform
		_context = platform.context
		_pool = GPU.BufferPool.new(_context)
		_smooth = GPU.Smooth.new(_context, _pool)
		_demoMaterial = _context.createMaterial(QUAD_FORMAT, GLSLX_SOURCE_DEMO_VERTEX, GLSLX_SOURCE_DEMO_FRAGMENT)
		_glyphMaterial = _context.createMaterial(Glyph.VERTEX_FORMAT, GLSLX_SOURCE_GLYPH_VERTEX, GLSLX_SOURCE_GLYPH_FRAGMENT)
		_textMaterial = _context.createMaterial(QUAD_FORMAT, GLSLX_SOURCE_TEXT_VERTEX, GLSLX_SOURCE_TEXT_FRAGMENT)
		_font = Font.new(fontData, _pool)
		_quad = _pool.allocate(QUAD_FORMAT, DataArray.new.appendFloats([-1, -1, 1, -1, -1, 1, 1, 1]).bytes)
		_color = _context.createTexture(.NEAREST_CLAMP, 0, 0)
		_target = _context.createTextureSet(_color)
		_origin.x = _platform.width / 2
		_origin.y = _platform.height / 2
	}

	def originX double {
		return _origin.x
	}

	def originY double {
		return _origin.y
	}

	def scale double {
		return _scale
	}

	def setOriginAndScale(originX double, originY double, scale double) {
		_origin.x = originX
		_origin.y = originY
		_scale = scale
	}

	def translateOrigin(deltaX double, deltaY double) {
		_origin.x += deltaX
		_origin.y += deltaY
	}

	def adjustScaleWithPin(x double, y double, ratio double) {
		_origin.x += (x - _origin.x) * (1 - ratio)
		_origin.y += (y - _origin.y) * (1 - ratio)
		_scale *= ratio
	}

	def beginFrame {
		if _color.width != _platform.pixelWidth || _color.height != _platform.pixelHeight {
			_color.resize(_platform.pixelWidth, _platform.pixelHeight, null)
		}

		_transformA.reset
		_transformA.translate(-1, 1)
		_transformA.scale(2.0 / _platform.width, -2.0 / _platform.height)
		_smooth.setTransformAndPixelScale(_transformA, 1 / _platform.density)

		_usedInstances = 0
		_context.setViewport(0, 0, _platform.pixelWidth, _platform.pixelHeight)
		_context.setCopyBlendState
		_context.clear(.WHITE)
	}

	def addGlyph(codePoint int, x double, y double, scale double) Glyph {
		if _usedInstances == _instances.count {
			_instances.append(GlyphInstance.new)
		}

		var instance = _instances[_usedInstances]
		instance.glyph = _font.glyph(codePoint)
		instance.offset.set(x, y + _font.ascender * scale)
		instance.scale = scale
		_usedInstances++

		assert(_usedInstances <= _instances.count)
		assert(instance.glyph != null)
		return instance.glyph
	}

	def addLine(ax double, ay double, bx double, by double) {
		_smooth.strokeLine(ax, ay, bx, by, .BLACK, 1)
	}

	def addSelectionBox(x double, y double, width double, height double) {
		_smooth.fillRect(x, y, width, height, SELECTION_COLOR)
	}

	def lineHeight double {
		return _font.ascender - _font.descender
	}

	def measureGlyph(codePoint int) double {
		return _font.glyph(codePoint).advanceWidth
	}

	def _computeTextWidth(text string, scale double) double {
		var width = 0.0
		for i in 0..text.count {
			width += scale * measureGlyph(text[i])
		}
		return width
	}

	def _addText(text string, x double, y double, scale double) {
		for i in 0..text.count {
			x += scale * addGlyph(text[i], x, y, scale).advanceWidth
		}
	}

	def _formatNumber(value double) string {
		var text string = (+(value as dynamic).toFixed(6)).toString()
		if text[0] == '-' {
			return "âˆ’" + text.slice(1)
		}
		return text
	}

	def drawGrid {
		var origin = _origin
		var scale = _scale
		var width = _platform.width
		var height = _platform.height

		# Grid lines
		var step = Math.pow(10, Math.round(Math.log(scale / 64) / Math.log(10)))
		var ratio = step / scale
		var left = Math.ceil(-origin.x * ratio) as int
		var top = Math.ceil((height - origin.y) * -ratio) as int
		var right = Math.ceil((width - origin.x) * ratio) as int
		var bottom = Math.ceil(-origin.y * -ratio) as int

		# Horizontal axis
		for x in left..right {
			var tx = origin.x + x * scale / step
			_smooth.strokeLineWithoutEndpointAA(tx, 0, tx, height, x == 0 ? .BLACK : x % 10 == 0 ? GRID_DARK_COLOR : GRID_LIGHT_COLOR, x == 0 ? 2 : 1)
		}

		# Vertical axis
		for y in top..bottom {
			var ty = origin.y - y * scale / step
			_smooth.strokeLineWithoutEndpointAA(0, ty, width, ty, y == 0 ? .BLACK : y % 10 == 0 ? GRID_DARK_COLOR : GRID_LIGHT_COLOR, y == 0 ? 2 : 1)
		}

		# Coordinate text and tick marks
		var log = Math.log(scale / 100) / Math.log(10)
		var intPart = Math.floor(log)
		var fractPart = log - intPart
		var textStep = Math.pow(10, intPart) * (
			fractPart > Math.log(5) / Math.log(10) ? 5 :
			fractPart > Math.log(2) / Math.log(10) ? 2 :
			1)
		var textRatio = textStep / scale
		var textLeft = Math.ceil((-100 - origin.x) * textRatio) as int
		var textTop = Math.ceil((height - origin.y) * -textRatio) as int
		var textRight = Math.ceil((width - origin.x) * textRatio) as int
		var textBottom = Math.ceil((-100 - origin.y) * -textRatio) as int

		# Horizontal axis
		var textY = Math.clamp(origin.y, 0, height - GRID_FONT_SIZE * 1.3)
		for x in textLeft..textRight {
			var tx = origin.x + x * scale / textStep
			if x != 0 {
				_smooth.strokeLine(tx, origin.y - GRID_TICK_SIZE, tx, origin.y + GRID_TICK_SIZE, .BLACK, 2)
			}
			_addText(_formatNumber(x / textStep), tx + GRID_FONT_SIZE * 0.3, textY + GRID_FONT_SIZE * 0.1, GRID_FONT_SIZE)
		}

		# Vertical axis
		var textX = Math.max(origin.x, 0) + GRID_FONT_SIZE * 0.3
		for y in textTop..textBottom {
			if y != 0 {
				var text = _formatNumber(y / textStep)
				var ty = origin.y - y * scale / textStep
				_smooth.strokeLine(origin.x - GRID_TICK_SIZE, ty, origin.x + GRID_TICK_SIZE, ty, .BLACK, 2)
				_addText(text, Math.min(textX, width - _computeTextWidth(text, GRID_FONT_SIZE) - GRID_FONT_SIZE * 0.3),
					ty + GRID_FONT_SIZE * 0.1, GRID_FONT_SIZE)
			}
		}
	}

	def flushSmoothGeometry {
		_context.setPremultipliedBlendState
		_smooth.flush
	}

	def drawFunction {
		_transformA.reset
		_transformA.scale(1 / _scale, -1 / scale)
		_transformA.translate(-_origin.x, -_origin.y)
		_transformA.scale(_platform.width * 0.5, -_platform.height * 0.5)
		_transformA.translate(1, -1)

		_demoMaterial.setUniformFloat(GLSLX_NAME_LINE_THICKNESS, 2 * _platform.density)
		_demoMaterial.setUniformMat3(GLSLX_NAME_MATRIX3, _transformA)
		_context.setPremultipliedBlendState
		_context.draw(.TRIANGLE_STRIP, _demoMaterial, _quad)
	}

	def flushText {
		_transformA.reset
		_transformA.translate(-1, 1)
		_transformA.scale(2.0 / _platform.width, -2.0 / _platform.height)

		# Switch to the offscreen render target
		_context.setTextureSet(_target)
		_context.clear(.TRANSPARENT)
		_context.setViewport(0, 0, _platform.pixelWidth, _platform.pixelHeight)
		_context.setAddBlendState

		# Take multiple samples of glyph outlines using the GPU
		var scale = 1 / _platform.density
		for i in 0.._usedInstances {
			var instance = _instances[i]
			if instance.glyph.area != null {
				for j in 0..JITTER_PATTERN.count {
					var offset = JITTER_PATTERN[j]
					_transformB.set(_transformA)
					_transformB.translate(instance.offset)
					_transformB.translate(offset.x * scale, offset.y * scale)
					_transformB.scale(instance.scale)
					if j % 2 == 0 {
						_glyphMaterial.setUniformVec3(GLSLX_NAME_COLOR, j == 0 ? 1 : 0, j == 2 ? 1 : 0, j == 4 ? 1 : 0)
					}
					_glyphMaterial.setUniformMat3(GLSLX_NAME_MATRIX3, _transformB)
					_context.draw(.TRIANGLES, _glyphMaterial, instance.glyph.area)
				}
			}
		}

		# Composite the offscreen render target back onto the canvas using the non-zero winding rule
		_context.setTextureSet(null)
		_context.setBlendState(.ZERO, .SOURCE_COLOR)
		_textMaterial.setUniformSampler(GLSLX_NAME_TEXTURE, _color, 0)
		_context.draw(.TRIANGLE_STRIP, _textMaterial, _quad)
	}
}

namespace Canvas {
	const GRID_FONT_SIZE = 16
	const GRID_TICK_SIZE = 5
	const SELECTION_COLOR = Color.new(0, 127, 255, 63)
	const GRID_LIGHT_COLOR = Color.new(0, 0, 0, 31)
	const GRID_DARK_COLOR = Color.new(0, 0, 0, 127)
	const QUAD_FORMAT = GPU.VertexFormat.new.add(GLSLX_NAME_POSITION2, .FLOAT, 2)

	# 6x subpixel AA pattern
	#
	#   R = (f(x - 2/3, y) + f(x - 1/3, y) + f(x, y)) / 3
	#   G = (f(x - 1/3, y) + f(x, y) + f(x + 1/3, y)) / 3
	#   B = (f(x, y) + f(x + 1/3, y) + f(x + 2/3, y)) / 3
	#
	# The shader would require three texture lookups if the texture format
	# stored data for offsets -1/3, 0, and +1/3 since the shader also needs
	# data for offsets -2/3 and +2/3. To avoid this, the texture format stores
	# data for offsets 0, +1/3, and +2/3 instead. That way the shader can get
	# data for offsets -2/3 and -1/3 with only one additional texture lookup.
	#
	const JITTER_PATTERN = [
		Vector.new(-1 / 12.0, -5 / 12.0),
		Vector.new( 1 / 12.0,  1 / 12.0),
		Vector.new( 3 / 12.0, -1 / 12.0),
		Vector.new( 5 / 12.0,  5 / 12.0),
		Vector.new( 7 / 12.0, -3 / 12.0),
		Vector.new( 9 / 12.0,  3 / 12.0),
	]
}
