class GlyphInstance {
	var glyph Glyph = null
	var offset = Vector.new
	var scale = 0.0
}

class Canvas {
	var _context GPU.Context
	var _pool GPU.BufferPool
	var _smooth GPU.SmoothRenderer
	var _demoMaterial GPU.Material
	var _glyphMaterial GPU.Material
	var _textMaterial GPU.Material
	var _font Font
	var _quad GPU.BufferArea
	var _color GPU.Texture
	var _target GPU.TextureSet
	var _instances List<GlyphInstance> = []
	var _usedInstances = 0

	# Viewport size
	var _width = 0
	var _height = 0
	var _pixelWidth = 0
	var _pixelHeight = 0
	var _density = 1.0

	# Event handlers
	var onScroll fn(double, double) = null
	var onPinch fn(double, double, double) = null
	var onResize fn() = null
	var onTouchStart fn(double, double, double) = null
	var onTouchMove fn(double, double, double) = null
	var onTouchEnd fn(double, double, double) = null

	# Temporary objects to avoid GC
	var _transformA = Transform.new
	var _transformB = Transform.new

	def new(fontData DataArray) {
		_context = GPU.HTMLContext.new
		_pool = GPU.BufferPool.new(_context)
		_smooth = GPU.SmoothRenderer.new(_context, _pool)
		(_context as GPU.HTMLContext).gl.getExtension("OES_standard_derivatives")
		_demoMaterial = _context.createMaterial(QUAD_FORMAT, GLSLX_SOURCE_DEMO_VERTEX, GLSLX_SOURCE_DEMO_FRAGMENT)
		_glyphMaterial = _context.createMaterial(Glyph.VERTEX_FORMAT, GLSLX_SOURCE_GLYPH_VERTEX, GLSLX_SOURCE_GLYPH_FRAGMENT)
		_textMaterial = _context.createMaterial(QUAD_FORMAT, GLSLX_SOURCE_TEXT_VERTEX, GLSLX_SOURCE_TEXT_FRAGMENT)
		_font = Font.new(fontData, _pool)
		_quad = _pool.allocate(QUAD_FORMAT, DataArray.new.appendFloats([-1, -1, 1, -1, -1, 1, 1, 1]).bytes)
		_color = _context.createTexture(.RGBA_NEAREST_CLAMP, 0, 0)
		_target = _context.createTextureSet(_color)
		_attachToDOM(_context as GPU.HTMLContext)
	}

	def _attachToDOM(context GPU.HTMLContext) {
		var isOSX = navigator.platform == "MacIntel" || navigator.platform == "MacPPC"
		var canvas = context.gl.canvas
		var centroid = Vector.new

		var resize = => {
			_width = window.innerWidth
			_height = window.innerHeight
			_density = window.devicePixelRatio

			_pixelWidth = Math.round(_width * _density) as int
			_pixelHeight = Math.round(_height * _density) as int

			context.resize(_pixelWidth, _pixelHeight)
			_color.resize(_pixelWidth, _pixelHeight, null)

			_transformA.reset
			_transformA.translate(-1, 1)
			_transformA.scale(2.0 / _width, -2.0 / _height)
			_smooth.setTransformAndPixelScale(_transformA, 1 / _density)

			if onResize != null {
				onResize()
			}
		}

		var computeCentroid = (touches List<HTMLTouch>, centroid Vector) => {
			centroid.set(0, 0)
			for touch in touches {
				centroid.x += touch.pageX
				centroid.y += touch.pageY
			}
			centroid /= touches.count
		}

		var computeDistance = (touches List<HTMLTouch>, centroid Vector) double => {
			var distance = 0.0
			for touch in touches {
				var dx = touch.pageX - centroid.x
				var dy = touch.pageY - centroid.y
				distance += Math.sqrt(dx * dx + dy * dy)
			}
			return distance / touches.count
		}

		canvas.addEventListener("wheel", (e HTMLWheelEvent) => {
			var swap = !isOSX && e.shiftKey
			if e.ctrlKey || isOSX && e.metaKey {
				if onPinch != null {
					onPinch(e.pageX, e.pageY, e.deltaY)
				}
			} else {
				if onScroll != null {
					onScroll(
						swap ? e.deltaY : e.deltaX,
						swap ? e.deltaX : e.deltaY)
				}
			}
			e.preventDefault
		})

		canvas.addEventListener("touchstart", (e HTMLTouchEvent) => {
			e.preventDefault

			if onTouchStart != null {
				var touches = e.touches
				computeCentroid(touches, centroid)
				onTouchStart(centroid.x, centroid.y, computeDistance(touches, centroid))
			}
		})

		canvas.addEventListener("touchmove", (e HTMLTouchEvent) => {
			if onTouchMove != null {
				var touches = e.touches
				computeCentroid(touches, centroid)
				onTouchMove(centroid.x, centroid.y, computeDistance(touches, centroid))
			}
		})

		canvas.addEventListener("touchend", (e HTMLTouchEvent) => {
			if onTouchEnd != null {
				var touches = e.touches
				computeCentroid(touches, centroid)
				onTouchEnd(centroid.x, centroid.y, computeDistance(touches, centroid))
			}
		})

		window.addEventListener("resize", resize)
		document.body.appendChild(canvas)
		resize()
	}

	def beginFrame {
		_usedInstances = 0
		_context.setCopyBlendState
		_context.clear(.WHITE)
	}

	def _addGlyph(codePoint int, offsetX double, offsetY double, scale double) Glyph {
		if _usedInstances == _instances.count {
			_instances.append(GlyphInstance.new)
		}

		var instance = _instances[_usedInstances]
		instance.glyph = _font.glyph(codePoint)
		instance.offset.set(offsetX, offsetY + _font.ascender * scale)
		instance.scale = scale
		_usedInstances++

		assert(_usedInstances <= _instances.count)
		assert(instance.glyph != null)
		return instance.glyph
	}

	def _computeTextWidth(text string, scale double) double {
		var width = 0.0
		for i in 0..text.count {
			width += scale * _font.glyph(text[i]).advanceWidth
		}
		return width
	}

	def _addText(text string, offsetX double, offsetY double, scale double) {
		for i in 0..text.count {
			offsetX += scale * _addGlyph(text[i], offsetX, offsetY, scale).advanceWidth
		}
	}

	def _formatNumber(value double) string {
		var text string = (+(value as dynamic).toFixed(6)).toString()
		if text[0] == '-' {
			return "âˆ’" + text.slice(1)
		}
		return text
	}

	def drawGrid(origin Vector, scale double) {
		# Grid lines
		var step = Math.pow(10, Math.round(Math.log(scale / 64) / Math.log(10)))
		var ratio = step / scale
		var left = Math.ceil(-origin.x * ratio) as int
		var top = Math.ceil(-origin.y * ratio) as int
		var right = Math.ceil((_width - origin.x) * ratio) as int
		var bottom = Math.ceil((_height - origin.y) * ratio) as int

		# Horizontal axis
		for x in left..right {
			var tx = origin.x + x * scale / step
			_smooth.strokeLine(tx, 0, tx, _height, x == 0 ? .BLACK : x % 10 == 0 ? GRID_DARK : GRID_LIGHT, x == 0 ? 2 : 1)
		}

		# Vertical axis
		for y in top..bottom {
			var ty = origin.y + y * scale / step
			_smooth.strokeLine(0, ty, _width, ty, y == 0 ? .BLACK : y % 10 == 0 ? GRID_DARK : GRID_LIGHT, y == 0 ? 2 : 1)
		}

		# Coordinate text and tick marks
		var log = Math.log(scale / 100) / Math.log(10)
		var intPart = Math.floor(log)
		var fractPart = log - intPart
		var textStep = Math.pow(10, intPart) * (
			fractPart > Math.log(5) / Math.log(10) ? 5 :
			fractPart > Math.log(2) / Math.log(10) ? 2 :
			1)
		var textRatio = textStep / scale
		var textLeft = Math.ceil((-100 - origin.x) * textRatio) as int
		var textTop = Math.ceil((-100 - origin.y) * textRatio) as int
		var textRight = Math.ceil((_width - origin.x) * textRatio) as int
		var textBottom = Math.ceil((_height - origin.y) * textRatio) as int

		# Horizontal axis
		var textY = Math.clamp(origin.y, 0, _height - GRID_FONT_SIZE * 1.3)
		for x in textLeft..textRight {
			var tx = origin.x + x * scale / textStep
			if x != 0 {
				_smooth.strokeLine(tx, origin.y - GRID_TICK_SIZE, tx, origin.y + GRID_TICK_SIZE, .BLACK, 2)
			}
			_addText(_formatNumber(x / textStep), tx + GRID_FONT_SIZE * 0.3, textY + GRID_FONT_SIZE * 0.1, GRID_FONT_SIZE)
		}

		# Vertical axis
		var textX = Math.max(origin.x, 0) + GRID_FONT_SIZE * 0.3
		for y in textTop..textBottom {
			if y != 0 {
				var text = _formatNumber(y / textStep)
				var ty = origin.y + y * scale / textStep
				_smooth.strokeLine(origin.x - GRID_TICK_SIZE, ty, origin.x + GRID_TICK_SIZE, ty, .BLACK, 2)
				_addText(text, Math.min(textX, _width - _computeTextWidth(text, GRID_FONT_SIZE) - GRID_FONT_SIZE * 0.3),
					ty + GRID_FONT_SIZE * 0.1, GRID_FONT_SIZE)
			}
		}
	}

	def drawSmoothGeometry {
		_context.setPremultipliedBlendState
		_smooth.flush
	}

	def drawFunction(origin Vector, scale double) {
		_transformA.reset
		_transformA.scale(1 / scale)
		_transformA.translate(-origin.x, -origin.y)
		_transformA.scale(_width * 0.5, -_height * 0.5)
		_transformA.translate(1, -1)

		_demoMaterial.setUniformFloat(GLSLX_NAME_LINE_THICKNESS, 2 * _density)
		_demoMaterial.setUniformMat3(GLSLX_NAME_MATRIX3, _transformA)
		_context.setPremultipliedBlendState
		_context.draw(.TRIANGLE_STRIP, _demoMaterial, _quad)
	}

	def drawText(origin Vector, scale double) {
		_transformA.reset
		_transformA.translate(-1, 1)
		_transformA.scale(2.0 / _width, -2.0 / _height)

		# Switch to the offscreen render target
		_context.setTextureSet(_target)
		_context.clear(.TRANSPARENT)
		_context.setViewport(0, 0, _pixelWidth, _pixelHeight)
		_context.setAddBlendState

		# Take multiple samples of glyph outlines using the GPU
		for i in 0.._usedInstances {
			var instance = _instances[i]
			for offset in JITTER_PATTERN {
				_transformB.set(_transformA)
				_transformB.translate(instance.offset)
				_transformB.translate(offset.x / _density, offset.y / _density)
				_transformB.scale(instance.scale)
				_glyphMaterial.setUniformMat3(GLSLX_NAME_MATRIX3, _transformB)
				_context.draw(.TRIANGLES, _glyphMaterial, instance.glyph.area)
			}
		}

		# Composite the offscreen render target back onto the canvas using the non-zero winding rule
		_context.setTextureSet(null)
		_context.setPremultipliedBlendState
		_textMaterial.setUniformSampler(GLSLX_NAME_TEXTURE, _color, 0)
		_context.draw(.TRIANGLE_STRIP, _textMaterial, _quad)
	}
}

namespace Canvas {
	const GRID_FONT_SIZE = 16
	const GRID_TICK_SIZE = 5
	const GRID_LIGHT = Color.new(0, 0, 0, 31)
	const GRID_DARK = Color.new(0, 0, 0, 127)
	const QUAD_FORMAT = GPU.VertexFormat.new.add(GLSLX_NAME_POSITION2, .FLOAT, 2)

	if true {
		# 8x MSAA pattern
		const JITTER_PATTERN = [
			Vector.new(-3 / 16.0, -5 / 16.0),
			Vector.new( 5 / 16.0,  1 / 16.0),
			Vector.new(-1 / 16.0,  3 / 16.0),
			Vector.new( 7 / 16.0, -7 / 16.0),
			Vector.new( 1 / 16.0, -3 / 16.0),
			Vector.new(-5 / 16.0,  5 / 16.0),
			Vector.new( 3 / 16.0,  7 / 16.0),
			Vector.new(-7 / 16.0, -1 / 16.0),
		]
	} else {
		# 4x MSAA pattern
		const JITTER_PATTERN = [
			Vector.new( 1 / 8.0,  3 / 8.0),
			Vector.new(-1 / 8.0, -3 / 8.0),
			Vector.new( 3 / 8.0, -1 / 8.0),
			Vector.new(-3 / 8.0,  1 / 8.0),
		]
	}
}
