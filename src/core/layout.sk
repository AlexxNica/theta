namespace Layout {
	enum Cursor {
		HIDE_CURSOR
		SHOW_CURSOR
	}

	enum Direction {
		LEFT
		RIGHT

		def opposite Direction {
			return (1 - self) as Direction
		}

		def delta int {
			return self == LEFT ? -1 : 1
		}
	}

	enum Boundary {
		CHARACTER
		WORD
		LINE
		DOCUMENT
	}

	enum Behavior {
		RESET
		EXTEND
	}

	const CODE_POINTS_WITH_SPACES = {
		'÷': 0,
		'=': 0,
		'<': 0,
		'>': 0,
		'≤': 0,
		'≥': 0,
	}

	################################################################################

	class Box {
		var x = 0.0
		var y = 0.0
		var width = 0.0
		var upperHeight = 0.0
		var lowerHeight = 0.0

		def height double {
			return upperHeight + lowerHeight
		}

		def contains(px double, py double) bool {
			px -= x
			py -= y
			return 0 <= px && px < width && y <= py && py < height
		}
	}

	################################################################################

	interface Renderer {
		def glyphCompiler GlyphCompiler
		def lineHeight double
		def glyph(codePoint int, prefer Prefer) Glyph
		def addGlyph(glyph Glyph, x double, y double, scale double)
		def addBox(x double, y double, width double, height double)
		def addSelectionBox(x double, y double, width double, height double)
		def addErrorLine(x1 double, x2 double, y double)
	}

	################################################################################

	class Anchor {
		const element Element
		const relativeIndex int # The global index adjusted so 0 is the start of this element
		const internalIndex int # The index inside the element (a index into element.children for a Container, for example)
		const child Anchor

		def containerElement Container {
			assert(element is Container)
			return element as Container
		}

		def deepestAnchor Anchor {
			var anchor = self
			while anchor.child != null {
				anchor = anchor.child
			}
			assert(anchor.element is Container)
			return anchor
		}

		def secondDeepestAnchor Anchor {
			var anchor = self
			while anchor.child != null && anchor.child.child != null {
				anchor = anchor.child
			}
			assert(anchor.child == null || anchor.child.element is Container)
			return anchor
		}
	}

	################################################################################

	class Range {
		var _root Container
		var _start Anchor
		var _end Anchor

		def clone(root Container) Range {
			return new(root,
				root.anchorAt(_start.relativeIndex),
				root.anchorAt(_end.relativeIndex))
		}

		def root Container {
			return _root
		}

		def start Anchor {
			return _start
		}

		def end Anchor {
			return _end
		}

		def min Anchor {
			return _start.relativeIndex < _end.relativeIndex ? _start : _end
		}

		def max Anchor {
			return _start.relativeIndex < _end.relativeIndex ? _end : _start
		}

		def expandedRange Range {
			var lower = min
			var upper = max
			var a = lower
			var b = upper

			# Find the deepest common parent container
			while a.child != null && b.child != null && a.internalIndex == b.internalIndex && (
					a.child.element is Container || a.child.internalIndex == b.child.internalIndex) {
				a = a.child
				b = b.child
			}

			# Return a new range that bounds the anchors
			assert(a.containerElement == b.containerElement)
			a = _root.anchorAt(lower.relativeIndex - a.relativeIndex + a.element.anchorCountBefore(a.internalIndex))
			b = _root.anchorAt(upper.relativeIndex - b.relativeIndex + b.element.anchorCountBefore(b.internalIndex + (b.child != null ? 1 : 0)))
			assert(a.deepestAnchor.containerElement == b.deepestAnchor.containerElement)
			return new(_root, a, b)
		}

		def isEmpty bool {
			return _start.relativeIndex == _end.relativeIndex
		}

		def extractSelection Container {
			var range = expandedRange
			var anchor = range.start.deepestAnchor
			var container = Container.new
			for i in anchor.internalIndex..range.end.deepestAnchor.internalIndex {
				container.children.append(anchor.containerElement.children[i].clone)
			}
			return container
		}

		def delete {
			var range = expandedRange
			var anchor = range.start.deepestAnchor
			anchor.containerElement.children.removeRange(anchor.internalIndex, range.end.deepestAnchor.internalIndex)
			_start = _end = range.start
		}

		def render(renderer Renderer, cursor Cursor) {
			assert(_start.element == _root)
			assert(_end.element == _root)

			if !isEmpty {
				var rect = expandedRange.bounds
				renderer.addSelectionBox(rect.x, rect.y, rect.width, rect.height)
			} else if cursor == .SHOW_CURSOR {
				var rect = bounds
				renderer.addBox(rect.x - 0.5, rect.y, 1, rect.height)
			}
		}

		def changeAnchor(both Anchor) {
			assert(both.element == _root)
			assert(0 <= both.relativeIndex && both.relativeIndex < _root.anchorCount)
			_start = _end = both
		}

		def changeAnchors(start Anchor, end Anchor) {
			assert(start.element == _root && end.element == _root)
			assert(0 <= start.relativeIndex && start.relativeIndex < _root.anchorCount)
			assert(0 <= end.relativeIndex && end.relativeIndex < _root.anchorCount)
			_start = start
			_end = end
		}

		def move(direction Direction, boundary Boundary, behavior Behavior) {
			var originalRange = expandedRange
			var current = _start

			if behavior == .RESET {
				_start = _end = isEmpty
					? _move(_root, current, direction, boundary)
					: direction == .LEFT ? originalRange.min : originalRange.max
			}

			else {
				assert(behavior == .EXTEND)

				while true {
					var next = _move(_root, current, direction, boundary)
					if next.relativeIndex == current.relativeIndex {
						break
					}
					current = next

					var range = Range.new(_root, current, _end).expandedRange
					if range.start.relativeIndex != originalRange.start.relativeIndex ||
							range.end.relativeIndex != originalRange.end.relativeIndex {
						break
					}
				}

				_start = current
			}
		}

		def bounds Rect {
			var start = self.start.deepestAnchor
			var end = self.end.deepestAnchor

			assert(start.containerElement == end.containerElement)
			assert(start.relativeIndex <= end.relativeIndex)

			var container = start.containerElement
			var children = container.children
			var box = container.box
			var startX = box.x
			var endX = box.x

			# Accumulate the widths of all previous children
			for i in 0..start.internalIndex {
				startX += children[i].box.width
			}
			for i in 0..end.internalIndex {
				endX += children[i].box.width
			}

			# Adjust the bounds by the padding of the characters on the ends
			if startX != endX {
				if start.internalIndex < children.count {
					startX += children[start.internalIndex].paddingLeft
				}
				if end.internalIndex > 0 {
					endX -= children[end.internalIndex - 1].paddingRight
				}
			}

			# Fir a box around everything
			var left = Math.min(startX, endX)
			var right = Math.max(startX, endX)
			var bounds = Rect.new
			bounds.set(left, box.y, right - left, box.height)

			# Empty containers have non-zero width
			if children.isEmpty {
				bounds.x += box.width / 2
			}

			return bounds
		}
	}

	namespace Range {
		def _move(root Container, anchor Anchor, direction Direction, boundary Boundary) Anchor {
			var moved = root.anchorAt(Math.clamp(anchor.relativeIndex + direction.delta, 0, root.anchorCount - 1))

			if boundary != .CHARACTER {
				var range = Range.new(root, anchor, moved).expandedRange
				var expanded = direction == .LEFT ? range.start : range.end
				var deepest = expanded.deepestAnchor
				var indexBase = expanded.relativeIndex - deepest.relativeIndex

				if boundary == .DOCUMENT {
					moved = root.anchorAt(direction == .LEFT ? 0 : root.anchorCount - 1)
				}

				else if boundary == .LINE {
					moved = root.anchorAt(indexBase + (direction == .LEFT ? 0 : deepest.containerElement.anchorCount - 1))
				}

				else {
					assert(boundary == .WORD)

					var container = deepest.containerElement
					var count = container.children.count
					var i = deepest.internalIndex

					if direction == .LEFT {
						var kind = container.elementKindRight(i)
						while i > 0 && container.elementKindLeft(i) == kind {
							i--
						}
					}

					else {
						var kind = container.elementKindLeft(i)
						while i < count && container.elementKindRight(i) == kind {
							i++
						}
					}

					moved = root.anchorAt(indexBase + container.anchorCountBefore(i))
				}
			}

			return moved
		}
	}

	################################################################################

	enum ElementKind {
		OTHER
		OPERAND
		FUNCTION

		def isOperand bool {
			return self != OTHER
		}
	}

	class Element {
		var box = Box.new
		var paddingLeft = 0.0
		var paddingRight = 0.0

		def containerClone Container {
			assert(clone is Container)
			return clone as Container
		}

		def clone Element
		def elementKind ElementKind
		def anchorCount int
		def anchorCountBefore(index int) int
		def anchorAt(index int) Anchor
		def anchorIndexFromPoint(x double, y double) int
		def calculateSize(renderer Renderer, previous Element, parentFontSize double)
		def updateLayout(x double, y double)
		def render(renderer Renderer)
	}

	namespace Element {
		const BASE_FONT_SIZE = 28.0
		const MIN_FONT_SIZE = 16.0
	}

	################################################################################

	class Character : Element {
		const codePoint int
		var functionID = INVALID_FUNCTION_ID
		var fontSize = 0.0

		over clone Element {
			var clone = new(codePoint)
			clone.functionID = functionID
			return clone
		}

		over elementKind ElementKind {
			var c = codePoint
			return
				functionID != INVALID_FUNCTION_ID ? .FUNCTION :
				Glyph.isWordCodePoint(c) ||
				c >= '0' && c <= '9' || c == '.' ||
				c == '!'
				? .OPERAND : .OTHER
		}

		over anchorCount int {
			return 0
		}

		over anchorCountBefore(index int) int {
			assert(false)
			return 0
		}

		over anchorAt(index int) Anchor {
			assert(false)
			return null
		}

		over anchorIndexFromPoint(x double, y double) int {
			return x < box.x + box.width / 2 ? -1 : 0
		}

		over calculateSize(renderer Renderer, previous Element, parentFontSize double) {
			var previousFunctionID =
				previous is Character ? (previous as Character).functionID :
				previous == null ? functionID :
				INVALID_FUNCTION_ID

			paddingLeft = paddingRight = 0
			fontSize = parentFontSize

			# Add space on both sides of the glyph
			if codePoint in CODE_POINTS_WITH_SPACES || (codePoint == '+' || codePoint == '-') && previous != null && previous.elementKind == .OPERAND {
				paddingLeft = paddingRight = renderer.glyph(' ', .PREFER_NORMAL).advanceWidth * parentFontSize
			}

			# Add space after the glyph
			else if codePoint == ',' {
				paddingRight = renderer.glyph(' ', .PREFER_NORMAL).advanceWidth * parentFontSize
			}

			# Add space before the glyph
			else if functionID != previousFunctionID && (previousFunctionID != INVALID_FUNCTION_ID || previous.elementKind.isOperand) {
				paddingLeft = renderer.glyph(' ', .PREFER_NORMAL).advanceWidth * parentFontSize
			}

			box.width = glyph(renderer).advanceWidth * parentFontSize + paddingLeft + paddingRight
			box.upperHeight = renderer.lineHeight * parentFontSize * UPPER_FONT_RATIO
			box.lowerHeight = renderer.lineHeight * parentFontSize * LOWER_FONT_RATIO
		}

		over updateLayout(x double, y double) {
			box.x = x
			box.y = y
		}

		over render(renderer Renderer) {
			renderer.addGlyph(glyph(renderer), box.x + paddingLeft, box.y, fontSize)
		}

		def glyph(renderer Renderer) Glyph {
			return renderer.glyph(codePoint == '-' ? '−' : codePoint == '*' ? '·' : codePoint, functionID != INVALID_FUNCTION_ID ? .PREFER_NORMAL : .PREFER_ITALIC)
		}
	}

	namespace Character {
		const UPPER_FONT_RATIO = 0.6
		const LOWER_FONT_RATIO = 0.4
		const INVALID_FUNCTION_ID = 0
	}

	################################################################################

	class Container : Element {
		var children List<Element> = []

		over clone Element {
			var clone = new
			for child in children {
				clone.children.append(child.clone)
			}
			return clone
		}

		over elementKind ElementKind {
			assert(false)
			return .OTHER
		}

		over anchorCount int {
			return anchorCountBefore(children.count) + 1
		}

		over anchorCountBefore(index int) int {
			assert(0 <= index && index <= children.count)
			var count = 0
			for i in 0..index {
				count += 1 + children[i].anchorCount
			}
			return count
		}

		over anchorAt(index int) Anchor {
			assert(index >= 0 && index < anchorCount)
			var relativeIndex = index

			for i in 0..children.count {
				# Check before the child
				if relativeIndex == 0 {
					return Anchor.new(self, index, i, null)
				}
				relativeIndex--

				# Check inside the child
				var child = children[i]
				var count = child.anchorCount
				if relativeIndex < count {
					return Anchor.new(self, index, i, child.anchorAt(relativeIndex))
				}
				relativeIndex -= count
			}

			# Must be after all children
			assert(relativeIndex == 0)
			return Anchor.new(self, index, children.count, null)
		}

		over anchorIndexFromPoint(x double, y double) int {
			# Left side
			if x <= box.x {
				return 0
			}

			var baseIndex = 0

			# Scan over the children
			for i in 0..children.count {
				var child = children[i]
				var childX = child.box.x
				var childWidth = child.box.width

				# Is the point inside this child?
				if x <= childX + childWidth {
					return baseIndex + 1 + child.anchorIndexFromPoint(x, y)
				}

				baseIndex += 1 + child.anchorCount
			}

			# Right side
			return baseIndex
		}

		over calculateSize(renderer Renderer, previous Element, parentFontSize double) {
			box.width = 0
			box.upperHeight = 0
			box.lowerHeight = 0

			# Stack children up horizontally
			previous = null
			for child in children {
				child.calculateSize(renderer, previous, parentFontSize)
				box.width += child.box.width
				box.upperHeight = Math.max(box.upperHeight, child.box.upperHeight)
				box.lowerHeight = Math.max(box.lowerHeight, child.box.lowerHeight)
				previous = child
			}

			# If the container is empty, leave some height for the cursor
			if children.isEmpty {
				box.width = 4
				box.upperHeight = renderer.lineHeight * parentFontSize * Character.UPPER_FONT_RATIO
				box.lowerHeight = renderer.lineHeight * parentFontSize * Character.LOWER_FONT_RATIO
			}
		}

		over updateLayout(x double, y double) {
			box.x = x
			box.y = y

			# Center all children about the line between the upper and lower parts
			for child in children {
				child.updateLayout(x, y + box.upperHeight - child.box.upperHeight)
				x += child.box.width
			}
		}

		over render(renderer Renderer) {
			for child in children {
				child.render(renderer)
			}
		}

		def elementKindLeft(index int) ElementKind {
			return index > 0 ? children[index - 1].elementKind : .OTHER
		}

		def elementKindRight(index int) ElementKind {
			return index < children.count ? children[index].elementKind : .OTHER
		}
	}

	################################################################################

	enum SpecialKind {
		ABSOLUTE_VALUE
		BRACKETS
		CEIL
		FLOOR
		FRACTION
		OVER
		PARENTHESES
		SQUARE_ROOT
		UNDER
	}

	class Special : Element {
		const kind SpecialKind
		const children List<Container> = []
		var fontSize = 0.0

		over clone Element {
			var clone = new(kind)
			for child in children {
				clone.children.append(child.containerClone)
			}
			return clone
		}

		over elementKind ElementKind {
			return .OPERAND
		}

		over anchorCount int {
			var total = 0
			for child in children {
				total += child.anchorCount
			}
			return total
		}

		over anchorCountBefore(index int) int {
			assert(0 <= index && index < children.count)
			var total = 0
			for i in 0..index {
				total += children[i].anchorCount
			}
			return total
		}

		over anchorAt(index int) Anchor {
			assert(index >= 0 && index < anchorCount)
			var relative = index

			for i in 0..children.count {
				var child = children[i]
				var count = child.anchorCount
				if relative < count {
					return Anchor.new(self, index, i, child.anchorAt(relative))
				}
				relative -= count
			}

			assert(false)
			return null
		}

		over anchorIndexFromPoint(x double, y double) int {
			assert(!children.isEmpty)
			var box = self.box
			var first = children[0]
			var firstBox = first.box

			switch kind {
				case .FRACTION {
					assert(children.count == 2)
					var second = children[1]
					var child = y < second.box.y ? first : second
					var childBox = child.box

					return
						x < (box.x + childBox.x) / 2 ? -1 :
						x > (box.x + box.width + childBox.x + childBox.width) / 2 ? anchorCount :
						child.anchorIndexFromPoint(x, y) + (child == second ? first.anchorCount : 0)
				}

				case .OVER, .UNDER {
					assert(children.count == 1)
					return
						x < box.x ? -1 :
						x > box.x + box.width ? anchorCount :
						first.anchorIndexFromPoint(x, y)
				}

				case .ABSOLUTE_VALUE, .BRACKETS, .CEIL, .FLOOR, .PARENTHESES, .SQUARE_ROOT {
					assert(children.count == 1)
					return
						x < (box.x + firstBox.x) / 2 ? -1 :
						x > (box.x + box.width + firstBox.x + firstBox.width) / 2 ? anchorCount :
						first.anchorIndexFromPoint(x, y)
				}
			}

			assert(false)
			return -1
		}

		over calculateSize(renderer Renderer, previous Element, parentFontSize double) {
			assert(!children.isEmpty)
			var first = children[0]

			switch kind {
				case .FRACTION {
					fontSize = Math.max(Element.MIN_FONT_SIZE, parentFontSize * FRACTION_FONT_RATIO)
				}

				case .OVER, .UNDER {
					fontSize = Math.max(Element.MIN_FONT_SIZE, parentFontSize * OVER_UNDER_FONT_RATIO)
				}

				default {
					fontSize = parentFontSize
				}
			}

			for child in children {
				child.calculateSize(renderer, null, fontSize)
			}

			switch kind {
				case .FRACTION {
					assert(children.count == 2)
					var second = children[1]

					# Add space after functions
					paddingLeft = 0
					if previous is Character && (previous as Character).functionID != Character.INVALID_FUNCTION_ID {
						paddingLeft = renderer.glyph(' ', .PREFER_NORMAL).advanceWidth * parentFontSize / 2
					}

					box.width = Math.max(first.box.width, second.box.width) + 8 + paddingLeft
					box.upperHeight = first.box.height + 2
					box.lowerHeight = second.box.height
				}

				case .OVER {
					assert(children.count == 1)
					box.width = first.box.width
					box.upperHeight = (previous != null ? Math.max(0, previous.box.upperHeight - parentFontSize * Character.UPPER_FONT_RATIO) : 0) + first.box.height
					box.lowerHeight = 0
				}

				case .UNDER {
					assert(children.count == 1)
					box.width = first.box.width
					box.upperHeight = 0
					box.lowerHeight = (previous != null ? Math.max(0, previous.box.lowerHeight - parentFontSize * Character.LOWER_FONT_RATIO) : 0) + first.box.height
				}

				case .SQUARE_ROOT {
					box.width = first.box.width + 0.7 * fontSize
					box.upperHeight = first.box.upperHeight
					box.lowerHeight = first.box.lowerHeight
				}

				case .ABSOLUTE_VALUE, .BRACKETS, .CEIL, .FLOOR, .PARENTHESES {
					box.width = first.box.width + fontSize * (kind == .ABSOLUTE_VALUE || kind == .PARENTHESES ? 2 / 3.0 : 0.8)
					box.upperHeight = first.box.upperHeight
					box.lowerHeight = first.box.lowerHeight
 				}
			}
		}

		over updateLayout(x double, y double) {
			assert(!children.isEmpty)
			var first = children[0]

			box.x = x
			box.y = y

			switch kind {
				case .FRACTION {
					assert(children.count == 2)
					first.updateLayout(x + (box.width + paddingLeft - first.box.width) / 2, y)
					children[1].updateLayout(x + (box.width + paddingLeft - children[1].box.width) / 2, y + box.upperHeight)
				}

				case .OVER {
					assert(children.count == 1)
					first.updateLayout(x, y)
				}

				case .UNDER {
					assert(children.count == 1)
					first.updateLayout(x, y + box.height - first.box.height)
				}

				case .SQUARE_ROOT {
					assert(children.count == 1)
					first.updateLayout(x + 0.55 * fontSize, y + box.height - first.box.height)
				}

				case .ABSOLUTE_VALUE, .BRACKETS, .CEIL, .FLOOR, .PARENTHESES {
					assert(children.count == 1)
					first.updateLayout(x + (box.width - first.box.width) / 2, y)
				}
			}
		}

		over render(renderer Renderer) {
			for child in children {
				child.render(renderer)
			}

			switch kind {
				case .FRACTION {
					renderer.addBox(box.x + paddingLeft + 2, box.y + box.upperHeight - 0.5, box.width - paddingLeft - 4, 1)
				}

				case .ABSOLUTE_VALUE, .BRACKETS, .CEIL, .FLOOR {
					var width = fontSize / 3
					var y = width * 0.5

					renderer.addBox(box.x + width * 0.4, box.y + y, width * 0.2, box.height - y)
					renderer.addBox(box.x + box.width - width * 0.6, box.y + y, width * 0.2, box.height - y)

					# Bottom bracket
					if kind == .FLOOR || kind == .BRACKETS {
						renderer.addBox(box.x + width * 0.6, box.y + box.height - width * 0.2, width * 0.4, width * 0.2)
						renderer.addBox(box.x + box.width - width, box.y + box.height - width * 0.2, width * 0.4, width * 0.2)
					}

					# Top bracket
					if kind == .CEIL || kind == .BRACKETS {
						renderer.addBox(box.x + width * 0.6, box.y + y, width * 0.4, width * 0.2)
						renderer.addBox(box.x + box.width - width, box.y + y, width * 0.4, width * 0.2)
					}
				}

				case .SQUARE_ROOT {
					var compiler = renderer.glyphCompiler
					var glyph = Glyph.new
					var width = box.width
					var height = box.height
					var y = height * 0.5

					compiler.begin(glyph)
					compiler.moveTo(fontSize * 0.47, 0)
					compiler.lineTo(width - fontSize * 0.1, 0)
					compiler.lineTo(width - fontSize * 0.1, fontSize * 0.05)
					compiler.lineTo(fontSize * 0.52, fontSize * 0.05)
					compiler.lineTo(fontSize * 0.36, height - fontSize * 0.03)
					compiler.lineTo(fontSize * 0.12, y)
					compiler.lineTo(fontSize * 0.02, y + fontSize * 0.05)
					compiler.lineTo(0, y)
					compiler.lineTo(fontSize * 0.16, y - fontSize * 0.08)
					compiler.lineTo(fontSize * 0.33, height * 0.75)
					compiler.end
					renderer.addGlyph(glyph, box.x, box.y, 1)
				}

				case .PARENTHESES {
					var compiler = renderer.glyphCompiler
					var glyph = Glyph.new

					var width = fontSize / 3
					var x0 = width * 0.15
					var x1 = width * 0.4
					var x2 = width * 0.8
					var x3 = width * 0.9

					var y = width * 0.5
					var height = box.height - y
					var y0 = y
					var y1 = y + height * 0.2
					var y2 = y + height * 0.5
					var y3 = y + height * 0.8
					var y4 = y + height

					compiler.begin(glyph)

					# Left parenthesis, outer curve
					compiler.moveTo(x2, y4)
					compiler.curveTo(x0, y3, x0, y2)
					compiler.curveTo(x0, y1, x2, y0)

					# Left parenthesis, inner curve
					compiler.lineTo(x3, y0)
					compiler.curveTo(x1, y1, x1, y2)
					compiler.curveTo(x1, y3, x3, y4)

					# Right parenthesis, outer curve
					compiler.moveTo(box.width - x3, y4)
					compiler.curveTo(box.width - x1, y3, box.width - x1, y2)
					compiler.curveTo(box.width - x1, y1, box.width - x3, y0)

					# Right parenthesis, inner curve
					compiler.lineTo(box.width - x2, y0)
					compiler.curveTo(box.width - x0, y1, box.width - x0, y2)
					compiler.curveTo(box.width - x0, y3, box.width - x2, y4)

					compiler.end
					renderer.addGlyph(glyph, box.x, box.y, 1)
				}
			}
		}
	}

	namespace Special {
		const FRACTION_FONT_RATIO = 0.8
		const OVER_UNDER_FONT_RATIO = 0.5
	}

	################################################################################

	enum Editor.Change {
		SELECTION
		CONTENTS
	}

	interface Editor.Delegate {
		def handleEditorChange(change Change)
	}

	class Editor.HistoryState {
		var root Container
		var undoSelection Range
		var redoSelection Range
	}

	class Editor {
		const _renderer Renderer
		const _originX int
		const _originY int
		var _root = Container.new
		var _selection Range
		var _selectionBeforeChange Range = null
		var _delegate Delegate = null
		var _history List<HistoryState> = []
		var _historyIndex = 0
		var _generatedFunctionID = Character.INVALID_FUNCTION_ID

		def new(renderer Renderer, originX int, originY int) {
			_renderer = renderer
			_originX = originX
			_originY = originY
			_updateLayout
			_selection = Range.new(_root, _root.anchorAt(0), _root.anchorAt(0))
			resetHistory
		}

		def hasSelection bool {
			return !_selection.isEmpty
		}

		def box Box {
			return _root.box
		}

		def setDelegate(delegate Delegate) {
			_delegate = delegate
		}

		def render(cursor Cursor) {
			_root.render(_renderer)
			_selection.render(_renderer, cursor)
		}

		def renderErrorForRange(start int, end int) {
			var bounds = Range.new(_root, _root.anchorAt(start), _root.anchorAt(end)).bounds
			_renderer.addErrorLine(bounds.x, bounds.x + bounds.width, bounds.y + bounds.height)
		}

		def undo {
			if _historyIndex > 0 {
				var state = _history[--_historyIndex]
				_restore(state, state.undoSelection)
			}
		}

		def redo {
			if _historyIndex + 1 < _history.count {
				var state = _history[++_historyIndex]
				_restore(state, state.redoSelection)
			}
		}

		def cloneContents Container {
			return _root.containerClone
		}

		def resetHistory {
			var root = _root.containerClone
			_history = [HistoryState.new(root, null, _selection.clone(root))]
			_historyIndex = 0
		}

		def selectAll {
			_selection.changeAnchors(_root.anchorAt(0), _root.anchorAt(_root.anchorCount - 1))
			_notifyDelegateOfChange(.SELECTION)
		}

		def selectRange(ax double, ay double, bx double, by double) {
			var start = _root.anchorIndexFromPoint(ax, ay)
			var end = _root.anchorIndexFromPoint(bx, by)

			if start != _selection.start.relativeIndex ||
					end != _selection.end.relativeIndex {
				_selection.changeAnchors(_root.anchorAt(start), _root.anchorAt(end))
				_notifyDelegateOfChange(.SELECTION)
			}
		}

		def cut Container {
			_recordBeforeChange
			var container = copy
			if !container.children.isEmpty {
				_selection.delete
				_applySubstitutions(_root, 0)
				_commitAfterChange
			}
			return container
		}

		def copy Container {
			return _selection.extractSelection
		}

		def isBeforeOperand bool {
			if _selection.isEmpty {
				var deepest = _selection.start.deepestAnchor
				return deepest.internalIndex != 0 && deepest.containerElement.children[deepest.internalIndex - 1].elementKind.isOperand
			}
			return false
		}

		def isAtEndOf(kind SpecialKind) bool {
			if _selection.isEmpty {
				var secondDeepest = _selection.start.secondDeepestAnchor

				# Check for an anchor inside a special element
				if secondDeepest.element is Special {
					var special = secondDeepest.element as Special
					return
						special.kind == kind && special.children.count == 1 &&
						secondDeepest.child.internalIndex == secondDeepest.child.containerElement.children.count
				}
			}

			return false
		}

		def selectWordBeforeSelection {
			if _selection.isEmpty {
				var deepest = _selection.start.deepestAnchor
				if deepest.containerElement.elementKindLeft(deepest.internalIndex).isOperand {
					_selection.move(.LEFT, .WORD, .EXTEND)
				}
			}
		}

		def move(direction Direction, boundary Boundary, behavior Behavior) {
			_selection.move(direction, boundary, behavior)
			_notifyDelegateOfChange(.SELECTION)
		}

		def delete(direction Direction, boundary Boundary) {
			_recordBeforeChange
			var changedSelection = false
			var insertAfterwards Container = null
			var directionAfterwards = Direction.LEFT

			# Try to create a selection to delete if nothing is selected
			if _selection.isEmpty {
				var anchor = _selection.start
				var deepest = anchor.deepestAnchor
				var children = deepest.containerElement.children
				var count = children.count
				var needsSelection = true

				# Is there something this anchor can move into?
				if direction == .LEFT ? deepest.internalIndex > 0 : deepest.internalIndex < count {
					var sibling = children[direction == .LEFT ? deepest.internalIndex - 1 : deepest.internalIndex]

					# Descend into special elements
					if sibling is Special {
						var containers = (sibling as Special).children
						assert(!containers.isEmpty)

						# Only descend if it contains something
						if containers.any(container => !container.children.isEmpty) {
							needsSelection = !(direction == .LEFT ? containers.last : containers.first).children.isEmpty
							_selection.changeAnchor(_root.anchorAt(anchor.relativeIndex + direction.delta))
							changedSelection = true
						}
					}
				}

				# Create a selection by moving in the chosen direction
				if needsSelection {
					assert(_selection.isEmpty)
					var secondDeepest = _selection.start.secondDeepestAnchor

					# Check for an anchor in a special element
					if secondDeepest.element is Special {
						var containers = (secondDeepest.element as Special).children
						var nestedChild = secondDeepest.child
						var container = nestedChild.containerElement
						assert(container in containers)

						# Does the special element have children?
						if !container.children.isEmpty {
							var nestedChildren = container.children
							var target = direction == .LEFT
								? nestedChild.internalIndex > 0 ? nestedChildren[nestedChild.internalIndex - 1] : null
								: nestedChild.internalIndex < nestedChildren.count ? nestedChildren[nestedChild.internalIndex] : null

							# If the cursor moved into this element, don't also delete a non-character element
							if target is Special {
								needsSelection = false
							}

							# Ungroup simple groups when the boundary is deleted
							else if target == null && containers.count == 1 {
								insertAfterwards = container
								directionAfterwards = direction
							}
						}

						# Ungroup a fraction when a delete is performed in an empty child container
						else if containers.count == 2 {
							insertAfterwards = containers[1 - containers.indexOf(container)]
							directionAfterwards = direction.opposite
						}
					}

					# Check again in case this flag was disabled
					if needsSelection {
						_selection.move(direction, boundary, .EXTEND)
					}
				}
			}

			if !_selection.isEmpty {
				_selection.delete

				# Put back content from within the deleted elements when ungrouping
				if insertAfterwards != null {
					_insert(insertAfterwards, directionAfterwards)
				}

				_applySubstitutions(_root, 0)
				_commitAfterChange
			}

			# Make sure to send a notification if this ended up being just a selection change
			else if changedSelection {
				_notifyDelegateOfChange(.SELECTION)
			}
		}

		def insert(container Container) {
			_recordBeforeChange
			if !container.children.isEmpty {
				_selection.delete
				_insert(container.containerClone, .RIGHT)
				_applySubstitutions(_root, 0)
				_commitAfterChange
			}
		}

		def _insert(container Container, side Direction) {
			assert(_selection.isEmpty)
			var anchor = _selection.start.deepestAnchor
			anchor.containerElement.children.insert(anchor.internalIndex, container.children)
			if side == .RIGHT {
				_selection.changeAnchor(_root.anchorAt(_selection.start.relativeIndex + container.anchorCount - 1))
			}
		}

		def _updateLayout {
			_root.calculateSize(_renderer, null, Element.BASE_FONT_SIZE)
			_root.updateLayout(_originX, _originY)
		}

		def _notifyDelegateOfChange(change Change) {
			if _delegate != null {
				_delegate.handleEditorChange(change)
			}
		}

		def _restore(state HistoryState, selection Range) {
			_root = state.root.containerClone
			_selection = selection.clone(_root)
			_updateLayout
			_notifyDelegateOfChange(.CONTENTS)
		}

		def _recordBeforeChange {
			_selectionBeforeChange = _selection.clone(_root)
		}

		def _commitAfterChange {
			var root = _root.containerClone
			var last = _history[_historyIndex]
			last.undoSelection = _selectionBeforeChange.clone(last.root)
			_history.removeRange(++_historyIndex, _history.count)
			_history.append(HistoryState.new(root, null, _selection.clone(root)))
			_updateLayout
			_notifyDelegateOfChange(.CONTENTS)
		}

		def _applySubstitutions(container Container, indexBase int) {
			var children = container.children
			var childIndexBase = indexBase
			var skipCount = 0
			var i = 0

			# Reset the counter before each round of substitutions
			if indexBase == 0 {
				_generatedFunctionID = Character.INVALID_FUNCTION_ID
			}

			# Move over all children, mutating the sequence with character substitutions
			while i < children.count {
				var child = children[i]

				# Character elements
				if child is Character && --skipCount < 0 {
					(child as Character).functionID = Character.INVALID_FUNCTION_ID
					var text = ""
					for j in i..children.count {
						var sibling = children[j]
						if !(sibling is Character) {
							break
						}
						text += string.fromCodePoint((sibling as Character).codePoint)
						var codePoint = SUBSTITUTIONS.get(text, INVALID_SUBSTITUTION)
						var isFunction = codePoint == INVALID_SUBSTITUTION && text in Equation.Parser.FUNCTIONS

						# Prevent substitutions inside incomplete words
						if codePoint == SKIP_SUBSTITUTION || isFunction {
							skipCount = j - i

							# Mark characters that are part of a function
							if isFunction {
								_generatedFunctionID++
								for k in i..j + 1 {
									assert(children[k] is Character)
									(children[k] as Character).functionID = _generatedFunctionID
								}
							}
						}

						# Substitute matching characters
						else if codePoint != INVALID_SUBSTITUTION {
							children.removeRange(i, j + 1)

							# Special substitutions
							if codePoint < 0 {
								child = Special.new(
									codePoint == ABSOLUTE_VALUE_SUBSTITUTION ? .ABSOLUTE_VALUE :
									codePoint == CEIL_SUBSTITUTION ? .CEIL :
									codePoint == FLOOR_SUBSTITUTION ? .FLOOR :
									codePoint == SQUARE_ROOT_SUBSTITUTION ? .SQUARE_ROOT :
									.PARENTHESES)
								(child as Special).children.append(Container.new)
							}

							# Normal characters
							else {
								child = Character.new(codePoint)
							}

							children.insert(i, child)
							var start = _selection.start.relativeIndex - childIndexBase
							var end = _selection.end.relativeIndex - childIndexBase
							if start > 0 {
								start = Math.max(1, start + i - j)
							}
							if end > 0 {
								end = Math.max(1, end + i - j)
							}
							_selection.changeAnchors(_root.anchorAt(childIndexBase + start), _root.anchorAt(childIndexBase + end))
							skipCount = 0
							break
						}
					}
				}

				# Special elements
				else if child is Special {
					var nestedIndexBase = childIndexBase + 1
					for nested in (child as Special).children {
						_applySubstitutions(nested, nestedIndexBase)
						nestedIndexBase += nested.anchorCount
					}
				}

				# Move to the next child
				childIndexBase += 1 + child.anchorCount
				i++
			}
		}
	}

	namespace Editor {
		const INVALID_SUBSTITUTION = 0
		const SKIP_SUBSTITUTION = -1
		const ABSOLUTE_VALUE_SUBSTITUTION = -2
		const CEIL_SUBSTITUTION = -3
		const FLOOR_SUBSTITUTION = -4
		const SQUARE_ROOT_SUBSTITUTION = -5
		const SUBSTITUTIONS = {
			"Alpha": 'Α',
			"alpha": 'α',
			"Beta": 'Β',
			"beta": 'β',
			"Chi": 'Χ',
			"chi": 'χ',
			"Delta": 'Δ',
			"delta": 'δ',
			"Epsilon": 'Ε',
			"epsilon": 'ε',
			"Eta": 'Η',
			"eta": 'η',
			"Gamma": 'Γ',
			"gamma": 'γ',
			"Iota": 'Ι',
			"iota": 'ι',
			"Kappa": 'Κ',
			"kappa": 'κ',
			"Lambda": 'Λ',
			"lambda": 'λ',
			"Mu": 'Μ',
			"mu": 'μ',
			"Nu": 'Ν',
			"nu": 'ν',
			"Omega": 'Ω',
			"omega": 'ω',
			"Omicron": 'Ο',
			"omicron": 'ο',
			"Phi": 'Φ',
			"phi": 'φ',
			"Pi": 'Π',
			"pi": 'π',
			"Psi": 'Ψ',
			"psi": 'ψ',
			"Rho": 'Ρ',
			"rho": 'ρ',
			"Sigma": 'Σ',
			"sigma": 'σ',
			"Tau": 'Τ',
			"tau": 'τ',
			"Theta": 'Θ',
			"theta": 'θ',
			"Upsilon": 'Υ',
			"upsilon": 'υ',
			"Xi": 'Ξ',
			"xi": 'ξ',
			"Zeta": 'Ζ',
			"zeta": 'ζ',

			# Prevent substitutions inside incomplete words
			"Epsi": SKIP_SUBSTITUTION,
			"epsi": SKIP_SUBSTITUTION,
			"Upsi": SKIP_SUBSTITUTION,
			"upsi": SKIP_SUBSTITUTION,

			# Non-character substitutions
			"abs": ABSOLUTE_VALUE_SUBSTITUTION,
			"ceil": CEIL_SUBSTITUTION,
			"floor": FLOOR_SUBSTITUTION,
			"sqrt": SQUARE_ROOT_SUBSTITUTION,
		}
	}
}
