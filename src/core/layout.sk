namespace Layout {
	enum Cursor {
		HIDE_CURSOR
		SHOW_CURSOR
	}

	enum Direction {
		LEFT
		RIGHT

		def delta int {
			return self == LEFT ? -1 : 1
		}
	}

	enum Boundary {
		CHARACTER
		WORD
		LINE
	}

	enum Behavior {
		RESET
		EXTEND
	}

	const CODE_POINTS_WITH_SPACES = {
		'÷': 0,
		'=': 0,
		'<': 0,
		'>': 0,
		'≤': 0,
		'≥': 0,
	}

	################################################################################

	class Box {
		var x = 0.0
		var y = 0.0
		var width = 0.0
		var upperHeight = 0.0
		var lowerHeight = 0.0

		def height double {
			return upperHeight + lowerHeight
		}
	}

	################################################################################

	interface Renderer {
		def lineHeight double
		def measureGlyph(codePoint int) double
		def addGlyph(codePoint int, x double, y double, scale double) Glyph
		def addLine(ax double, ay double, bx double, by double)
		def addSelectionBox(x double, y double, width double, height double)
	}

	################################################################################

	class Anchor {
		const element Element
		const relativeIndex int # The global index adjusted so 0 is the start of this element
		const internalIndex int # The index inside the element (a index into element.children for a Container, for example)
		const child Anchor

		def containerElement Container {
			assert(element is Container)
			return element as Container
		}

		def deepestAnchor Anchor {
			var anchor = self
			while anchor.child != null {
				anchor = anchor.child
			}
			assert(anchor.element is Container)
			return anchor
		}
	}

	################################################################################

	class Range {
		var _root Container
		var _start Anchor
		var _end Anchor

		def root Container {
			return _root
		}

		def start Anchor {
			return _start
		}

		def end Anchor {
			return _end
		}

		def min Anchor {
			return _start.relativeIndex < _end.relativeIndex ? _start : _end
		}

		def max Anchor {
			return _start.relativeIndex < _end.relativeIndex ? _end : _start
		}

		def expandedRange Range {
			var lower = min
			var upper = max
			var a = lower
			var b = upper

			# Find the deepest common parent container
			while a.child != null && b.child != null && a.internalIndex == b.internalIndex && (
					a.child.element is Container || a.child.internalIndex == b.child.internalIndex) {
				a = a.child
				b = b.child
			}

			# Return a new range that bounds the anchors
			assert(a.containerElement == b.containerElement)
			a = _root.anchorAt(lower.relativeIndex - a.relativeIndex + a.element.anchorCountBefore(a.internalIndex))
			b = _root.anchorAt(upper.relativeIndex - b.relativeIndex + b.element.anchorCountBefore(b.internalIndex + (b.child != null ? 1 : 0)))
			assert(a.deepestAnchor.containerElement == b.deepestAnchor.containerElement)
			return new(_root, a, b)
		}

		def isEmpty bool {
			return _start.relativeIndex == _end.relativeIndex
		}

		def extractSelection Container {
			var range = expandedRange
			var anchor = range.start.deepestAnchor
			var container = Container.new
			for i in anchor.internalIndex..range.end.deepestAnchor.internalIndex {
				container.children.append(anchor.containerElement.children[i].clone)
			}
			return container
		}

		def delete {
			var range = expandedRange
			var anchor = range.start.deepestAnchor
			anchor.containerElement.children.removeRange(anchor.internalIndex, range.end.deepestAnchor.internalIndex)
			_start = _end = range.start
		}

		def render(renderer Renderer, cursor Cursor) {
			assert(_start.element == _root)
			assert(_end.element == _root)

			if !isEmpty {
				_renderRange(renderer, expandedRange)
			} else if cursor == .SHOW_CURSOR {
				_renderAnchor(renderer, _start)
			}
		}

		def changeAnchor(both Anchor) {
			assert(both.element == _root)
			assert(0 <= both.relativeIndex && both.relativeIndex < _root.anchorCount)
			_start = _end = both
		}

		def changeAnchors(start Anchor, end Anchor) {
			assert(start.element == _root && end.element == _root)
			assert(0 <= start.relativeIndex && start.relativeIndex < _root.anchorCount)
			assert(0 <= end.relativeIndex && end.relativeIndex < _root.anchorCount)
			_start = start
			_end = end
		}

		def move(direction Direction, boundary Boundary, behavior Behavior) {
			var originalRange = expandedRange
			var current = _start

			if behavior == .RESET {
				_start = _end = isEmpty
					? _move(_root, current, direction, boundary)
					: direction == .LEFT ? originalRange.min : originalRange.max
			}

			else {
				assert(behavior == .EXTEND)

				while true {
					var next = _move(_root, current, direction, boundary)
					if next.relativeIndex == current.relativeIndex {
						break
					}
					current = next

					var range = Range.new(_root, current, _end).expandedRange
					if range.start.relativeIndex != originalRange.start.relativeIndex ||
							range.end.relativeIndex != originalRange.end.relativeIndex {
						break
					}
				}

				_start = current
			}
		}
	}

	namespace Range {
		def _move(root Container, anchor Anchor, direction Direction, boundary Boundary) Anchor {
			var moved = root.anchorAt(Math.clamp(anchor.relativeIndex + direction.delta, 0, root.anchorCount - 1))

			if boundary == .LINE {
				var range = Range.new(root, anchor, moved).expandedRange
				var deepest = range.start.deepestAnchor
				moved = root.anchorAt(range.start.relativeIndex - deepest.relativeIndex + (direction == .LEFT ? 0 : deepest.containerElement.anchorCount - 1))
			}

			return moved
		}

		def _renderRange(renderer Renderer, range Range) {
			var start = range.start.deepestAnchor
			var end = range.end.deepestAnchor
			assert(start.containerElement == end.containerElement)

			var container = start.containerElement
			var box = container.box
			var startX = box.x
			var endX = box.x

			# Accumulate the widths of all previous children
			for i in 0..start.internalIndex {
				startX += container.children[i].box.width
			}
			for i in 0..end.internalIndex {
				endX += container.children[i].box.width
			}

			var left = Math.min(startX, endX)
			var right = Math.max(startX, endX)
			renderer.addSelectionBox(left, box.y, right - left, box.height)
		}

		def _renderAnchor(renderer Renderer, anchor Anchor) {
			var deepest = anchor.deepestAnchor
			var container = deepest.containerElement
			var box = container.box
			var x = box.x

			# Accumulate the widths of all previous children
			for i in 0..deepest.internalIndex {
				x += container.children[i].box.width
			}

			# Center cursors in empty containers
			if container.children.isEmpty {
				x += box.width / 2
			}

			renderer.addLine(x, box.y, x, box.y + box.height)
		}
	}

	################################################################################

	class Element {
		var box = Box.new

		def clone Element
		def anchorCount int
		def anchorCountBefore(index int) int
		def anchorAt(index int) Anchor
		def calculateSize(renderer Renderer, previous Element, parentFontSize double)
		def updateLayout(x double, y double)
		def render(renderer Renderer)
	}

	namespace Element {
		const BASE_FONT_SIZE = 28
		const MIN_FONT_SIZE = 16
	}

	################################################################################

	class Character : Element {
		const codePoint int
		var paddingLeft = 0.0
		var fontSize = 0.0

		over clone Element {
			return new(codePoint)
		}

		over anchorCount int {
			return 0
		}

		over anchorCountBefore(index int) int {
			assert(false)
			return 0
		}

		over anchorAt(index int) Anchor {
			assert(false)
			return null
		}

		over calculateSize(renderer Renderer, previous Element, parentFontSize double) {
			box.width = renderer.measureGlyph(codePointWithSubstitution) * parentFontSize
			paddingLeft = 0
			fontSize = parentFontSize

			# Add space after the glyph
			if codePoint == ',' {
				box.width += renderer.measureGlyph(' ') * parentFontSize
			}

			# Add space on both sides of the glyph
			else if codePoint in CODE_POINTS_WITH_SPACES || _isTermSeparator(previous) {
				paddingLeft = renderer.measureGlyph(' ') * parentFontSize
				box.width += paddingLeft * 2
			}

			box.upperHeight = renderer.lineHeight * parentFontSize * UPPER_FONT_RATIO
			box.lowerHeight = renderer.lineHeight * parentFontSize * LOWER_FONT_RATIO
		}

		over updateLayout(x double, y double) {
			box.x = x
			box.y = y
		}

		over render(renderer Renderer) {
			renderer.addGlyph(codePointWithSubstitution, box.x + paddingLeft, box.y, fontSize)
		}

		def codePointWithSubstitution int {
			if codePoint == '-' { return '−' }
			if codePoint == '*' { return '·' }
			return codePoint
		}

		def _isTermSeparator(previous Element) bool {
			if codePoint != '+' && codePoint != '-' || previous == null {
				return false
			}
			if previous is Character {
				var c = (previous as Character).codePoint
				return c != '+' && c != '-' && c != '*' && c != '÷'
			}
			return true
		}
	}

	namespace Character {
		const UPPER_FONT_RATIO = 0.6
		const LOWER_FONT_RATIO = 0.4
	}

	################################################################################

	class Container : Element {
		var children List<Element> = []

		over clone Element {
			var clone = new
			for child in children {
				clone.children.append(child.clone)
			}
			return clone
		}

		over anchorCount int {
			return anchorCountBefore(children.count) + 1
		}

		over anchorCountBefore(index int) int {
			assert(0 <= index && index <= children.count)
			var count = 0
			for i in 0..index {
				count += 1 + children[i].anchorCount
			}
			return count
		}

		over anchorAt(index int) Anchor {
			assert(index >= 0 && index < anchorCount)
			var relativeIndex = index

			for i in 0..children.count {
				# Check before the child
				if relativeIndex == 0 {
					return Anchor.new(self, index, i, null)
				}
				relativeIndex--

				# Check inside the child
				var child = children[i]
				var count = child.anchorCount
				if relativeIndex < count {
					return Anchor.new(self, index, i, child.anchorAt(relativeIndex))
				}
				relativeIndex -= count
			}

			# Must be after all children
			assert(relativeIndex == 0)
			return Anchor.new(self, index, children.count, null)
		}

		over calculateSize(renderer Renderer, previous Element, parentFontSize double) {
			box.width = 0
			box.upperHeight = 0
			box.lowerHeight = 0

			# Stack children up horizontally
			previous = null
			for child in children {
				child.calculateSize(renderer, previous, parentFontSize)
				box.width += child.box.width
				box.upperHeight = Math.max(box.upperHeight, child.box.upperHeight)
				box.lowerHeight = Math.max(box.lowerHeight, child.box.lowerHeight)
				previous = child
			}

			# If the container is empty, leave some height for the cursor
			if children.isEmpty {
				box.width = 4
				box.upperHeight = box.lowerHeight = renderer.lineHeight * parentFontSize / 2
			}
		}

		over updateLayout(x double, y double) {
			box.x = x
			box.y = y

			# Center all children about the line between the upper and lower parts
			for child in children {
				child.updateLayout(x, y + box.upperHeight - child.box.upperHeight)
				x += child.box.width
			}
		}

		over render(renderer Renderer) {
			for child in children {
				child.render(renderer)
			}
		}
	}

	################################################################################

	enum Special.Kind {
		FRACTION
		OVER
		UNDER
	}

	class Special : Element {
		const kind Kind
		const children List<Container> = []

		over clone Element {
			var clone = new(kind)
			for child in children {
				clone.children.append(child.clone as Container)
			}
			return clone
		}

		over anchorCount int {
			var total = 0
			for child in children {
				total += child.anchorCount
			}
			return total
		}

		over anchorCountBefore(index int) int {
			assert(0 <= index && index < children.count)
			var total = 0
			for i in 0..index {
				total += children[i].anchorCount
			}
			return total
		}

		over anchorAt(index int) Anchor {
			assert(index >= 0 && index < anchorCount)
			var relative = index
			for i in 0..children.count {
				var child = children[i]
				var count = child.anchorCount
				if relative < count {
					return Anchor.new(self, index, i, child.anchorAt(relative))
				}
				relative -= count
			}
			assert(false)
			return null
		}

		over calculateSize(renderer Renderer, previous Element, parentFontSize double) {
			var fontSize = parentFontSize

			switch kind {
				case .FRACTION {
					fontSize = Math.max(Element.MIN_FONT_SIZE, fontSize * FRACTION_FONT_RATIO)
				}

				case .OVER, .UNDER {
					fontSize = Math.max(Element.MIN_FONT_SIZE, fontSize * OVER_UNDER_FONT_RATIO)
				}
			}

			for child in children {
				child.calculateSize(renderer, null, fontSize)
			}

			switch kind {
				case .FRACTION {
					assert(children.count == 2)
					var first = children[0]
					var second = children[1]

					box.width = Math.max(first.box.width, second.box.width) + 8
					box.upperHeight = first.box.height + 2
					box.lowerHeight = second.box.height
				}

				case .OVER {
					assert(children.count == 1)
					box.width = children[0].box.width
					box.upperHeight = (previous != null ? Math.max(0, previous.box.upperHeight - parentFontSize * Character.UPPER_FONT_RATIO) : 0) + children[0].box.height
					box.lowerHeight = 0
				}

				case .UNDER {
					assert(children.count == 1)
					box.width = children[0].box.width
					box.upperHeight = 0
					box.lowerHeight = (previous != null ? Math.max(0, previous.box.lowerHeight - parentFontSize * Character.LOWER_FONT_RATIO) : 0) + children[0].box.height
				}
			}
		}

		over updateLayout(x double, y double) {
			box.x = x
			box.y = y

			switch kind {
				case .FRACTION {
					assert(children.count == 2)
					children[0].updateLayout(x + (box.width - children[0].box.width) / 2, y)
					children[1].updateLayout(x + (box.width - children[1].box.width) / 2, y + box.upperHeight)
				}

				case .OVER {
					assert(children.count == 1)
					children[0].updateLayout(x, y)
				}

				case .UNDER {
					assert(children.count == 1)
					children[0].updateLayout(x, y + box.height - children[0].box.height)
				}
			}
		}

		over render(renderer Renderer) {
			for child in children {
				child.render(renderer)
			}

			switch kind {
				case .FRACTION {
					renderer.addLine(box.x + 2, box.y + box.upperHeight, box.x + box.width - 2, box.y + box.upperHeight)
				}
			}
		}
	}

	namespace Special {
		const FRACTION_FONT_RATIO = 0.8
		const OVER_UNDER_FONT_RATIO = 0.5
	}

	################################################################################

	enum Editor.Change {
		SELECTION
		CONTENTS
	}

	interface Editor.Delegate {
		def handleEditorChange(change Change)
	}

	class Editor {
		const _renderer Renderer
		const _originX int
		const _originY int
		const _root = Container.new
		const _selection Range
		var _delegate Delegate = null

		def new(renderer Renderer, originX int, originY int) {
			_renderer = renderer
			_originX = originX
			_originY = originY
			_updateLayout
			_selection = Range.new(_root, _root.anchorAt(0), _root.anchorAt(0))
		}

		def hasSelection bool {
			return !_selection.isEmpty
		}

		def setDelegate(delegate Delegate) {
			_delegate = delegate
		}

		def render(cursor Cursor) {
			_root.render(_renderer)
			_selection.render(_renderer, cursor)
		}

		def selectAll {
			_selection.changeAnchors(_root.anchorAt(0), _root.anchorAt(_root.anchorCount - 1))
			_notifyDelegate(.SELECTION)
		}

		def cut Container {
			var container = copy
			if !container.children.isEmpty {
				_selection.delete
				_updateLayout
				_notifyDelegate(.CONTENTS)
			}
			return container
		}

		def copy Container {
			return _selection.extractSelection
		}

		def _applySubstitutions(container Container, indexBase int) {
			var children = container.children
			var childIndexBase = indexBase
			var i = 0

			# Move over all children, mutating the sequence with character substitutions
			while i < children.count {
				var child = children[i]

				# Character elements
				if child is Character {
					var text = ""
					for j in i..children.count {
						var sibling = children[j]
						if !(sibling is Character) {
							break
						}
						text += string.fromCodePoint((sibling as Character).codePoint)

						# Substitute matching characters
						if text in SUBSTITUTIONS {
							children.removeRange(i, j + 1)
							child = Character.new(SUBSTITUTIONS[text])
							children.insert(i, child)
							var start = _selection.start.relativeIndex - childIndexBase
							var end = _selection.end.relativeIndex - childIndexBase
							if start > 0 {
								start = Math.max(1, start + i - j)
							}
							if end > 0 {
								end = Math.max(1, end + i - j)
							}
							_selection.changeAnchors(_root.anchorAt(childIndexBase + start), _root.anchorAt(childIndexBase + end))
							break
						}
					}
				}

				# Special elements
				else if child is Special {
					var nestedIndexBase = childIndexBase + 1
					for nested in (child as Special).children {
						_applySubstitutions(nested, nestedIndexBase)
						nestedIndexBase += nested.anchorCount
					}
				}

				else {
					assert(false)
				}

				# Move to the next child
				childIndexBase += 1 + child.anchorCount
				i++
			}
		}

		def move(direction Direction, boundary Boundary, behavior Behavior) {
			_selection.move(direction, boundary, behavior)
			_notifyDelegate(.SELECTION)
		}

		def delete(direction Direction, boundary Boundary) {
			if _selection.isEmpty {
				_selection.move(direction, boundary, .EXTEND)
			}
			if !_selection.isEmpty {
				_selection.delete
				_updateLayout
				_notifyDelegate(.CONTENTS)
			}
		}

		def insert(container Container) {
			if !container.children.isEmpty {
				_selection.delete
				var clone = container.clone as Container
				var anchor = _selection.start.deepestAnchor
				anchor.containerElement.children.insert(anchor.internalIndex, clone.children)
				_selection.changeAnchor(_root.anchorAt(_selection.start.relativeIndex + clone.anchorCount - 1))
				_applySubstitutions(_root, 0)
				_updateLayout
				_notifyDelegate(.CONTENTS)
			}
		}

		def _updateLayout {
			_root.calculateSize(_renderer, null, Element.BASE_FONT_SIZE)
			_root.updateLayout(_originX, _originY)
		}

		def _notifyDelegate(change Change) {
			if _delegate != null {
				_delegate.handleEditorChange(change)
			}
		}
	}

	namespace Editor {
		const SUBSTITUTIONS = {
			"Alpha": 'Α',
			"alpha": 'α',
			"Beta": 'Β',
			"beta": 'β',
			"Chi": 'Χ',
			"chi": 'χ',
			"Delta": 'Δ',
			"delta": 'δ',
			"Epsilon": 'Ε',
			"epsilon": 'ε',
			"Eta": 'Η',
			"eta": 'η',
			"Gamma": 'Γ',
			"gamma": 'γ',
			"Iota": 'Ι',
			"iota": 'ι',
			"Kappa": 'Κ',
			"kappa": 'κ',
			"Lambda": 'Λ',
			"lambda": 'λ',
			"Mu": 'Μ',
			"mu": 'μ',
			"Nu": 'Ν',
			"nu": 'ν',
			"Omega": 'Ω',
			"omega": 'ω',
			"Omicron": 'Ο',
			"omicron": 'ο',
			"Phi": 'Φ',
			"phi": 'φ',
			"Pi": 'Π',
			"pi": 'π',
			"Psi": 'Ψ',
			"psi": 'ψ',
			"Rho": 'Ρ',
			"rho": 'ρ',
			"Sigma": 'Σ',
			"sigma": 'σ',
			"Tau": 'Τ',
			"tau": 'τ',
			"Theta": 'Θ',
			"theta": 'θ',
			"Upsilon": 'Υ',
			"upsilon": 'υ',
			"Xi": 'Ξ',
			"xi": 'ξ',
			"Zeta": 'Ζ',
			"zeta": 'ζ',
		}
	}
}
