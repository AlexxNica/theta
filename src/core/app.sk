class App.OldTouch {
	const centerX double
	const centerY double
	const averageDistance double
	const touchCount int
	const time double
}

enum App.Animation {
	NONE
	DECAY
	EASE_IN_OUT
}

class App :: Platform.Delegate, Layout.Editor.Delegate {
	var _platform Platform
	var _canvas Canvas
	var _editor Layout.Editor
	var _fps = 60.0
	var _cursorToggleTime = 0.0
	var _isCursorVisible = true
	var _isInvalid = true
	var _idleFrames = 0
	var _oldTouches List<OldTouch> = []
	var _clipboard = Layout.Container.new
	var _oldMouseX = 0
	var _oldMouseY = 0

	# Animation support
	var _animation Animation = .NONE
	var _startOrigin = Vector.new
	var _startScale = 0.0
	var _startTime = 0.0
	var _endOrigin = Vector.new
	var _endScale = 0.0
	var _endTime = 0.0

	def new(platform Platform, fontData DataArray) {
		_platform = platform
		_canvas = Canvas.new(platform, fontData)
		_editor = Layout.Editor.new(_canvas, 20, 20)
		_createInitialContent
		_resetCursorBlink
		platform.setDelegate(self)
		_editor.setDelegate(self)
		_draw
	}

	def _createInitialContent {
		var c = Layout.Container.new
		c.children.append(Layout.Character.new('y'))
		c.children.append(Layout.Character.new('â‰¤'))
		c.children.append(Layout.Character.new('x'))
		_editor.insert(c)
		_editor.resetHistory
	}

	def handleFrame {
		var time = _platform.seconds

		if _animation != .NONE {
			var t = (time - _startTime) / (_endTime - _startTime)

			# Stop the animation once it's done
			if t > 1 {
				_canvas.setOriginAndScale(_endOrigin.x, _endOrigin.y, _endScale)
				_animation = .NONE
			}

			else {
				# Bend the animation curve for a more pleasant animation
				if _animation == .EASE_IN_OUT {
					t *= t * t * (t * (t * 6 - 15) + 10)
				} else {
					assert(_animation == .DECAY)
					t = 1 - t
					t = 1 - t * t * t * t * t
				}

				# Animate both origin and scale
				_canvas.setOriginAndScale(
					_startOrigin.x + (_endOrigin.x - _startOrigin.x) * t,
					_startOrigin.y + (_endOrigin.y - _startOrigin.y) * t,
					1 / (1 / _startScale + (1 / _endScale - 1 / _startScale) * t))
			}

			_invalidate
		}

		# Cursor invalidations don't count as user activity
		var shouldResetIdleFrames = _isInvalid

		# Toggle the cursor periodically
		if _platform.hasFocus && time > _cursorToggleTime && !_editor.hasSelection {
			_cursorToggleTime = time + CURSOR_BLINK_DELAY
			_isCursorVisible = !_isCursorVisible
			_invalidate
		}

		# Always draw immediately when invalid
		if _isInvalid {
			if shouldResetIdleFrames {
				_idleFrames = 0
			}
			_isInvalid = false
			_draw
		}

		# Render occasionally even when idle. Chrome must render at least 10fps to
		# avoid stutter when starting to render at 60fps again.
		else if _platform.hasFocus && ++_idleFrames % 6 == 0 && _idleFrames < 60 * 2 {
			_draw
		}
	}

	def handleScroll(deltaX double, deltaY double) {
		_stopAnimation
		_canvas.translateOrigin(-deltaX, -deltaY)
		_invalidate
	}

	def handlePinch(x double, y double, delta double) {
		_stopAnimation
		_canvas.adjustScaleWithPin(x, y, Math.pow(0.98, delta))
		_invalidate
	}

	def handleResize {
		_stopAnimation
		_draw
	}

	def handleTouchStart(centerX double, centerY double, averageDistance double, touchCount int) {
		_stopAnimation
		_oldTouches.append(OldTouch.new(centerX, centerY, averageDistance, touchCount, _platform.seconds))
	}

	def handleTouchMove(centerX double, centerY double, averageDistance double, touchCount int) {
		var previous = _oldTouches.last
		if previous.touchCount == touchCount {
			if averageDistance != 0 && previous.averageDistance != 0 {
				_canvas.adjustScaleWithPin(previous.centerX, previous.centerY, averageDistance / previous.averageDistance)
			}
			_canvas.translateOrigin(centerX - previous.centerX, centerY - previous.centerY)
			_invalidate
		}
		_oldTouches.append(OldTouch.new(centerX, centerY, averageDistance, touchCount, _platform.seconds))
	}

	def handleTouchEnd(centerX double, centerY double, averageDistance double, touchCount int) {
		if touchCount != 0 {
			_oldTouches.append(OldTouch.new(centerX, centerY, averageDistance, touchCount, _platform.seconds))
			return
		}

		var count = _oldTouches.count
		var time = _platform.seconds

		# Search for an old touch that was long enough ago that the velocity should be stable
		for i = count - 2; i >= 0; i-- {
			var before = _oldTouches[i]

			# Ignore touches due to a pinch gesture
			if before.touchCount > 1 {
				break
			}

			# Ignore old touches that are too recent
			if time - before.time > 0.1 {
				var after = _oldTouches[i + 1]
				var scale = 1 / (after.time - before.time)
				var velocity = Vector.new((after.centerX - before.centerX) * scale, (after.centerY - before.centerY) * scale)
				var speed = velocity.length
				var duration = Math.log(1 + speed) / 5
				var flingDistance = speed * duration / 5 # Divide by 5 since a quintic decay function has an initial slope of 5

				# Only fling if the speed is fast enough
				if speed > 50 {
					_startAnimation(.DECAY, duration)
					_endOrigin += velocity * (flingDistance / speed)
				}
				break
			}
		}

		_oldTouches = []
	}

	def handleMouseDown(x int, y int, buttons Platform.Buttons) {
		_oldMouseX = x
		_oldMouseY = y
	}

	def handleMouseMove(x int, y int, buttons Platform.Buttons) {
		if buttons != 0 {
			_canvas.translateOrigin(x - _oldMouseX, y - _oldMouseY)
			_invalidate
		}
		_oldMouseX = x
		_oldMouseY = y
	}

	def handleMouseUp(x int, y int, buttons Platform.Buttons) {
		_oldMouseX = x
		_oldMouseY = y
	}

	def handleShortcut(shortcut Platform.Shortcut) {
		switch shortcut {
			case .UNDO { _editor.undo }
			case .REDO { _editor.redo }
			case .SELECT_ALL { _editor.selectAll }
			case .CUT { _clipboard = _editor.cut }
			case .COPY { _clipboard = _editor.copy }
			case .PASTE { _editor.insert(_clipboard) }

			case .MOVE_LEFT_CHARACTER { _editor.move(.LEFT, .CHARACTER, .RESET) }
			case .MOVE_RIGHT_CHARACTER { _editor.move(.RIGHT, .CHARACTER, .RESET) }
			case .MOVE_LEFT_WORD { _editor.move(.LEFT, .WORD, .RESET) }
			case .MOVE_RIGHT_WORD { _editor.move(.RIGHT, .WORD, .RESET) }
			case .MOVE_LEFT_LINE { _editor.move(.LEFT, .LINE, .RESET) }
			case .MOVE_RIGHT_LINE { _editor.move(.RIGHT, .LINE, .RESET) }
			case .MOVE_UP_LINE { _editor.move(.LEFT, .LINE, .RESET) }
			case .MOVE_DOWN_LINE { _editor.move(.RIGHT, .LINE, .RESET) }
			case .MOVE_UP_DOCUMENT { _editor.move(.LEFT, .DOCUMENT, .RESET) }
			case .MOVE_DOWN_DOCUMENT { _editor.move(.RIGHT, .DOCUMENT, .RESET) }

			case .EXTEND_LEFT_CHARACTER { _editor.move(.LEFT, .CHARACTER, .EXTEND) }
			case .EXTEND_RIGHT_CHARACTER { _editor.move(.RIGHT, .CHARACTER, .EXTEND) }
			case .EXTEND_LEFT_WORD { _editor.move(.LEFT, .WORD, .EXTEND) }
			case .EXTEND_RIGHT_WORD { _editor.move(.RIGHT, .WORD, .EXTEND) }
			case .EXTEND_LEFT_LINE { _editor.move(.LEFT, .LINE, .EXTEND) }
			case .EXTEND_RIGHT_LINE { _editor.move(.RIGHT, .LINE, .EXTEND) }
			case .EXTEND_UP_LINE { _editor.move(.LEFT, .LINE, .EXTEND) }
			case .EXTEND_DOWN_LINE { _editor.move(.RIGHT, .LINE, .EXTEND) }
			case .EXTEND_UP_DOCUMENT { _editor.move(.LEFT, .DOCUMENT, .EXTEND) }
			case .EXTEND_DOWN_DOCUMENT { _editor.move(.RIGHT, .DOCUMENT, .EXTEND) }

			case .DELETE_LEFT_CHARACTER { _editor.delete(.LEFT, .CHARACTER) }
			case .DELETE_RIGHT_CHARACTER { _editor.delete(.RIGHT, .CHARACTER) }
			case .DELETE_LEFT_WORD { _editor.delete(.LEFT, .WORD) }
			case .DELETE_RIGHT_WORD { _editor.delete(.RIGHT, .WORD) }
			case .DELETE_LEFT_LINE { _editor.delete(.LEFT, .LINE) }
			case .DELETE_RIGHT_LINE { _editor.delete(.RIGHT, .LINE) }
		}
	}

	def handleCodePoint(c int) {
		var insertion = Layout.Container.new

		if c == '/' {
			_editor.selectWordBeforeSelection
			var special = Layout.Special.new(.FRACTION)
			var selection = _editor.copy
			special.children.append(selection)
			special.children.append(Layout.Container.new)
			insertion.children.append(special)
			_editor.insert(insertion)
			_editor.move(.LEFT, .CHARACTER, .RESET)
			if selection.children.isEmpty {
				_editor.move(.LEFT, .CHARACTER, .RESET)
			}
		}

		else if c == '^' || c == '_' || c == '|' || c == '[' || c == '(' {
			var special = Layout.Special.new(
				c == '^' ? .OVER :
				c == '_' ? .UNDER :
				c == '|' ? .ABSOLUTE_VALUE :
				c == '[' ? .BRACKETS :
				.PARENTHESES)
			var selection = _editor.copy
			special.children.append(selection)
			insertion.children.append(special)
			_editor.insert(insertion)
			_editor.move(.LEFT, .CHARACTER, .RESET)
			if !selection.children.isEmpty {
				_editor.move(.LEFT, .LINE, .EXTEND)
			}
		}

		else {
			insertion.children.append(Layout.Character.new(c))
			_editor.insert(insertion)
		}
	}

	def handleFocusChange {
		if _platform.hasFocus {
			_resetCursorBlink
		} else if _isCursorVisible {
			_isCursorVisible = false
			_invalidate
		}
	}

	def handleEditorChange(change Layout.Editor.Change) {
		_resetCursorBlink
	}

	def _invalidate {
		_isInvalid = true
	}

	def _startAnimation(animation Animation, duration double) {
		_animation = animation

		# Configure the start
		_startOrigin.x = _canvas.originX
		_startOrigin.y = _canvas.originY
		_startScale = _canvas.scale
		_startTime = _platform.seconds

		# Configure the end
		_endOrigin.set(_startOrigin)
		_endScale = _startScale
		_endTime = _startTime + duration
	}

	def _stopAnimation {
		_animation = .NONE
	}

	def _resetCursorBlink {
		_cursorToggleTime = _platform.seconds + CURSOR_BLINK_DELAY
		_isCursorVisible = true
		_invalidate
	}

	def _draw {
		_canvas.beginFrame
		_canvas.drawGrid
		_canvas.flushSmoothGeometry
		_canvas.drawFunction
		_editor.render(_isCursorVisible ? .SHOW_CURSOR : .HIDE_CURSOR)
		_canvas.flushText
		_canvas.flushSmoothGeometry
	}
}

namespace App {
	const CURSOR_BLINK_DELAY = 0.5

	@entry
	def main {
		var xhr = XMLHttpRequest.new
		xhr.open("GET", "fonts.bin")
		xhr.onload = => {
			var platform Platform

			try {
				platform = HTMLPlatform.new
			}

			catch e dynamic {
				if e && e.message == "Could not initialize WebGL" {
					document.write("This application requires WebGL.")
					return
				}
				throw e
			}

			new(platform, DataArray.new(Uint8Array.new(xhr.response)))
		}
		xhr.responseType = "arraybuffer"
		xhr.send
	}
}
