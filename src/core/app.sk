class App.OldTouch {
	var x double
	var y double
	var distance double
	var time double
}

enum App.Animation {
	NONE
	DECAY
	EASE_IN_OUT
}

class App {
	var _canvas Canvas
	var _editor Layout.Editor
	var _fps = 60.0
	var _isInvalid = true
	var _validFrames = 0
	var _cursorToggleFrameCount = 0
	var _isCursorVisible = true

	# Viewport transform
	var _origin = Vector.new(window.innerWidth / 2, window.innerHeight / 2)
	var _scale = 100.0

	# Animation support
	var _animation Animation = .NONE
	var _startOrigin = Vector.new
	var _startScale = 0.0
	var _startTime = 0.0
	var _endOrigin = Vector.new
	var _endScale = 0.0
	var _endTime = 0.0

	def new(fontData DataArray) {
		_canvas = Canvas.new(fontData)
		_editor = Layout.Editor.new(_canvas, 20, 20)
		_addEventHandlers
		_startRenderLoop

		var c = Layout.Container.new
		c.children.append(Layout.Character.new('y'))
		c.children.append(Layout.Character.new('â‰¤'))
		c.children.append(Layout.Character.new('x'))
		_editor.insert(c)
	}

	def _addEventHandlers {
		var oldTouches List<OldTouch> = []

		_canvas.onResize = => {
			_stopAnimation
			_draw
		}

		_canvas.onScroll = (x, y) => {
			_stopAnimation
			_origin.x -= x
			_origin.y -= y
			_invalidate
		}

		_canvas.onPinch = (x, y, delta) => {
			_stopAnimation
			_adjustScaleWithPin(x, y, Math.pow(0.98, delta))
		}

		_canvas.onTouchStart = (x, y, distance) => {
			_stopAnimation
			oldTouches.append(OldTouch.new(x, y, distance, _seconds))
		}

		_canvas.onTouchMove = (x, y, distance) => {
			var previous = oldTouches.last
			if distance != 0 && previous.distance != 0 {
				_adjustScaleWithPin(previous.x, previous.y, distance / previous.distance)
			} else {
				_invalidate
			}
			_origin.x += x - previous.x
			_origin.y += y - previous.y
			oldTouches.append(OldTouch.new(x, y, distance, _seconds))
		}

		_canvas.onTouchEnd = (x, y, distance) => {
			if distance.isNaN {
				var count = oldTouches.count
				var time = _seconds

				# Search for an old touch that was long enough ago that the velocity should be stable
				for i = count - 2; i >= 0; i-- {
					var before = oldTouches[i]

					if time - before.time > 0.1 {
						var after = oldTouches[i + 1]
						var scale = 1 / (after.time - before.time)
						var velocity = Vector.new((after.x - before.x) * scale, (after.y - before.y) * scale)
						var speed = velocity.length
						var duration = Math.log(1 + speed) / 5
						var flingDistance = speed * duration / 5 # Divide by 5 since a quintic decay function has an initial slope of 5

						if speed > 50 {
							_startAnimation(.DECAY, duration)
							_endOrigin += velocity * (flingDistance / speed)
						}

						break
					}
				}

				oldTouches = []
			} else {
				oldTouches.append(OldTouch.new(x, y, distance, _seconds))
			}
		}
	}

	def _seconds double {
		return performance.now / 1000
	}

	def _startAnimation(animation Animation, duration double) {
		_animation = animation

		# Configure the start
		_startOrigin.set(_origin)
		_startScale = _scale
		_startTime = _seconds

		# Configure the end
		_endOrigin.set(_startOrigin)
		_endScale = _startScale
		_endTime = _startTime + duration
	}

	def _stopAnimation {
		_animation = .NONE
	}

	def _adjustScaleWithPin(x double, y double, ratio double) {
		_origin.x += (x - _origin.x) * (1 - ratio)
		_origin.y += (y - _origin.y) * (1 - ratio)
		_scale *= ratio
		_invalidate
	}

	def _invalidate {
		_isInvalid = true
	}

	def _resetCursorBlink {
		_isCursorVisible = true
		_cursorToggleFrameCount = 0
	}

	def _startRenderLoop {
		var tick fn() = => {
			_tick
			requestAnimationFrame(tick)
		}
		tick()
	}

	def _tick {
		if _animation != .NONE {
			var t = (_seconds - _startTime) / (_endTime - _startTime)

			# Stop the animation once it's done
			if t > 1 {
				_origin.set(_endOrigin)
				_scale = _endScale
				_animation = .NONE
			}

			else {
				# Bend the animation curve for a more pleasant animation
				if _animation == .EASE_IN_OUT {
					t *= t * t * (t * (t * 6 - 15) + 10)
				} else {
					assert(_animation == .DECAY)
					t = 1 - t
					t = 1 - t * t * t * t * t
				}

				# Animate both origin and scale
				_scale = 1 / (1 / _startScale + (1 / _endScale - 1 / _startScale) * t)
				_origin.set(_endOrigin)
				_origin -= _startOrigin
				_origin *= t
				_origin += _startOrigin
			}

			_invalidate
		}

		# Toggle the cursor periodically
		if ++_cursorToggleFrameCount == 30 {
			_cursorToggleFrameCount = 0
			_isCursorVisible = !_isCursorVisible
		}

		# Always draw immediately when invalid
		if _isInvalid {
			_validFrames = 0
			_isInvalid = false
			_draw
		}

		# Render occasionally even when valid. Chrome must render at least 10fps to
		# avoid stutter when starting to render at 60fps again.
		else if _validFrames % 6 == 0 {
			_draw
		}
	}

	var _anchorIndex = 0

	def _draw {
		_canvas.beginFrame
		_canvas.drawGrid(_origin, _scale)
		_canvas.drawSmoothGeometry
		_canvas.drawFunction(_origin, _scale)
		_editor.render(_isCursorVisible)
		_canvas.drawText(_origin, _scale)
		_canvas.drawSmoothGeometry
	}
}

namespace App {
	@entry
	def main {
		var xhr = XMLHttpRequest.new
		xhr.open("GET", "fonts.bin")
		xhr.onload = => {
			new(DataArray.new(Uint8Array.new(xhr.response)))
		}
		xhr.responseType = "arraybuffer"
		xhr.send
	}
}
