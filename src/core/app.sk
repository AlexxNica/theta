class App.OldTouch {
	var centerX double
	var centerY double
	var averageDistance double
	var time double
}

enum App.Animation {
	NONE
	DECAY
	EASE_IN_OUT
}

class App :: Platform.Delegate {
	var _platform Platform
	var _canvas Canvas
	var _editor Layout.Editor
	var _fps = 60.0
	var _cursorToggleTime = 0.0
	var _isCursorVisible = true
	var _isInvalid = true
	var _validFrames = 0
	var _oldTouches List<OldTouch> = []

	# Animation support
	var _animation Animation = .NONE
	var _startOrigin = Vector.new
	var _startScale = 0.0
	var _startTime = 0.0
	var _endOrigin = Vector.new
	var _endScale = 0.0
	var _endTime = 0.0

	def new(platform Platform, fontData DataArray) {
		_platform = platform
		_canvas = Canvas.new(platform, fontData)
		_editor = Layout.Editor.new(_canvas, 20, 20)
		_createInitialContent
		_resetCursorBlink
		platform.setDelegate(self)
	}

	def _createInitialContent {
		var c = Layout.Container.new
		c.children.append(Layout.Character.new('y'))
		c.children.append(Layout.Character.new('â‰¤'))
		c.children.append(Layout.Character.new('x'))
		_editor.insert(c)
	}

	def handleFrame {
		var time = _platform.seconds

		if _animation != .NONE {
			var t = (time - _startTime) / (_endTime - _startTime)

			# Stop the animation once it's done
			if t > 1 {
				_canvas.setOriginAndScale(_endOrigin.x, _endOrigin.y, _endScale)
				_animation = .NONE
			}

			else {
				# Bend the animation curve for a more pleasant animation
				if _animation == .EASE_IN_OUT {
					t *= t * t * (t * (t * 6 - 15) + 10)
				} else {
					assert(_animation == .DECAY)
					t = 1 - t
					t = 1 - t * t * t * t * t
				}

				# Animate both origin and scale
				_canvas.setOriginAndScale(
					_startOrigin.x + (_endOrigin.x - _startOrigin.x) * t,
					_startOrigin.y + (_endOrigin.y - _startOrigin.y) * t,
					1 / (1 / _startScale + (1 / _endScale - 1 / _startScale) * t))
			}

			_invalidate
		}

		# Toggle the cursor periodically
		if time > _cursorToggleTime {
			_cursorToggleTime = time + CURSOR_BLINK_DELAY
			_isCursorVisible = !_isCursorVisible
		}

		# Always draw immediately when invalid
		if _isInvalid {
			_validFrames = 0
			_isInvalid = false
			_draw
		}

		# Render occasionally even when valid. Chrome must render at least 10fps to
		# avoid stutter when starting to render at 60fps again.
		else if _validFrames % 6 == 0 {
			_draw
		}
	}

	def handleScroll(deltaX double, deltaY double) {
		_stopAnimation
		_canvas.translateOrigin(-deltaX, -deltaY)
		_invalidate
	}

	def handlePinch(x double, y double, delta double) {
		_stopAnimation
		_canvas.adjustScaleWithPin(x, y, Math.pow(0.98, delta))
		_invalidate
	}

	def handleResize {
		_stopAnimation
		_draw
	}

	def handleTouchStart(centerX double, centerY double, averageDistance double) {
		_stopAnimation
		_oldTouches.append(OldTouch.new(centerX, centerY, averageDistance, _platform.seconds))
	}

	def handleTouchMove(centerX double, centerY double, averageDistance double) {
		var previous = _oldTouches.last
		if averageDistance != 0 && previous.averageDistance != 0 {
			_canvas.adjustScaleWithPin(previous.centerX, previous.centerY, averageDistance / previous.averageDistance)
		}
		_canvas.translateOrigin(centerX - previous.centerX, centerY - previous.centerY)
		_oldTouches.append(OldTouch.new(centerX, centerY, averageDistance, _platform.seconds))
		_invalidate
	}

	def handleTouchEnd(centerX double, centerY double, averageDistance double) {
		if !averageDistance.isNaN {
			_oldTouches.append(OldTouch.new(centerX, centerY, averageDistance, _platform.seconds))
			return
		}

		var count = _oldTouches.count
		var time = _platform.seconds

		# Search for an old touch that was long enough ago that the velocity should be stable
		for i = count - 2; i >= 0; i-- {
			var before = _oldTouches[i]

			# Ignore old touches that are too recent
			if time - before.time > 0.1 {
				var after = _oldTouches[i + 1]
				var scale = 1 / (after.time - before.time)
				var velocity = Vector.new((after.centerX - before.centerX) * scale, (after.centerY - before.centerY) * scale)
				var speed = velocity.length
				var duration = Math.log(1 + speed) / 5
				var flingDistance = speed * duration / 5 # Divide by 5 since a quintic decay function has an initial slope of 5

				# Only fling if the speed is fast enough
				if speed > 50 {
					_startAnimation(.DECAY, duration)
					_endOrigin += velocity * (flingDistance / speed)
				}
				break
			}
		}

		_oldTouches = []
	}

	def _invalidate {
		_isInvalid = true
	}

	def _startAnimation(animation Animation, duration double) {
		_animation = animation

		# Configure the start
		_startOrigin.x = _canvas.originX
		_startOrigin.y = _canvas.originY
		_startScale = _canvas.scale
		_startTime = _platform.seconds

		# Configure the end
		_endOrigin.set(_startOrigin)
		_endScale = _startScale
		_endTime = _startTime + duration
	}

	def _stopAnimation {
		_animation = .NONE
	}

	def _resetCursorBlink {
		_isCursorVisible = true
		_cursorToggleTime = _platform.seconds + CURSOR_BLINK_DELAY
	}

	def _draw {
		_canvas.beginFrame
		_canvas.drawGrid
		_canvas.flushSmoothGeometry
		_canvas.drawFunction
		_editor.render(_isCursorVisible)
		_canvas.flushText
		_canvas.flushSmoothGeometry
	}
}

namespace App {
	const CURSOR_BLINK_DELAY = 0.5

	@entry
	def main {
		var xhr = XMLHttpRequest.new
		xhr.open("GET", "fonts.bin")
		xhr.onload = => {
			new(HTMLPlatform.new, DataArray.new(Uint8Array.new(xhr.response)))
		}
		xhr.responseType = "arraybuffer"
		xhr.send
	}
}
